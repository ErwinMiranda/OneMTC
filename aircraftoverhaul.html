<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>One MTC</title>
    <!--
    REMOVED commented-out script block.
    All Firebase/auth logic is handled in the main script at the bottom.
    -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>
    <!-- Chart.js library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>

    <style>
      /* Import modern font */
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap");

      /* === Lufthansa Theme & Modernization === */
      :root {
        --lufthansa-blue: #05164d;
        --lufthansa-yellow: #ffb81c;
        --lufthansa-bg: #f8f9fa;
        --lufthansa-card-bg: #ffffff;
        --lufthansa-border: #dee2e6;
        --lufthansa-text: #212529;
        --lufthansa-text-light: #495057;
        --lufthansa-danger: #dc3545;
        --lufthansa-success: #28a745;
        --lufthansa-radius: 8px; /* Standardized border radius */
      }

      body {
        font-family: "Inter", sans-serif;
        margin: 0;
        background: var(--lufthansa-bg);
        color: var(--lufthansa-text);
      }

      /* === Header === */
      .plan-header {
        top: 0;
        z-index: 100;
        display: flex;
        justify-content: space-between;
        align-items: center;
        background: var(--lufthansa-blue);
        padding: 12px 20px;
        margin-bottom: 20px;
        color: white;
      }
      .plan-heading {
        font-size: 1.25rem;
        font-weight: 700;
        color: var(--lufthansa-yellow);
      }
      .liveUpdate {
        font-size: 0.8rem;
        color: #cbd5e1;
        margin-left: auto;
        padding-right: 16px;
      }
      .logout-btn {
        background: var(--lufthansa-yellow);
        color: var(--lufthansa-blue);
        border: none;
        padding: 6px 12px;
        font-size: 14px;
        font-weight: 600;
        border-radius: var(--lufthansa-radius);
        cursor: pointer;
        transition: background 0.2s ease;
      }
      .logout-btn:hover {
        background: #ffca4d;
      }

      /* === Main Layout Wrappers === */
      .main-wrapper {
        display: flex;
        gap: 20px;
        align-items: flex-start;
        padding: 0 20px 20px;
      }
      .main-content {
        flex: 4;
        min-width: 0;
      }
      .history {
        flex: 1;
        background: var(--lufthansa-card-bg);
        border: 1px solid var(--lufthansa-border);
        border-radius: var(--lufthansa-radius);
        padding: 16px;
        min-width: 250px;
        max-width: 350px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
        /* üîΩ ADD ALL OF THESE LINES üîΩ */
        position: sticky;
        top: 20px; /* This is the 20px padding from main-wrapper */

        /* Set a max height based on the screen, not the content */
        max-height: calc(
          100vh - 40px
        ); /* 100% viewport height - 40px for padding */

        /* Use flex to make the list inside fill the space */
        display: flex;
        flex-direction: column;
      }

      /* === Controls & Buttons === */
      .controls {
        display: flex;
        gap: 10px;
        align-items: center;
        margin-bottom: 15px;
        flex-wrap: wrap;
      }
      .controls input {
        flex: 1;
        min-width: 220px;
        padding: 8px 12px;
        font-size: 14px;
        border-radius: var(--lufthansa-radius);
        border: 1px solid var(--lufthansa-border);
        box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05);
      }
      .btn {
        padding: 8px 14px;
        font-size: 14px;
        font-weight: 500;
        border: none;
        color: #fff;
        border-radius: var(--lufthansa-radius);
        cursor: pointer;
        transition: all 0.2s ease;
      }
      #woSearchBtn {
        background: var(--lufthansa-blue);
      }
      #woSearchBtn:hover {
        background: #0a267c;
      }
      #startScanBtn {
        background: var(--lufthansa-yellow);
        color: var(--lufthansa-blue);
        font-weight: 600;
      }
      #startScanBtn:hover {
        background: #ffca4d;
      }
      #startScanBtn.scanning {
        background: #f0b01a;
        box-shadow: 0 0 0 3px rgba(255, 184, 28, 0.3);
      }
      #stopScanBtn {
        background: var(--lufthansa-danger);
      }
      #stopScanBtn:hover {
        background: #c82333;
      }

      /* === Skill Filters === */
      .skill-filters {
        margin: 10px 0 15px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .skill-filters button {
        position: relative;
        padding: 6px 12px;
        font-size: 14px;
        background: #e9ecef;
        color: var(--lufthansa-text-light);
        border: 1px solid var(--lufthansa-border);
        border-radius: 16px; /* Pill shape */
        cursor: pointer;
        transition: all 0.2s;
      }
      .skill-filters button:hover {
        background: #dee2e6;
      }
      .skill-filters button.active {
        background: var(--lufthansa-blue);
        border-color: var(--lufthansa-blue);
        color: #fff;
        font-weight: 600;
      }
      .comment-badge {
        position: absolute;
        top: -6px;
        right: -6px;
        background: var(--lufthansa-danger);
        color: white;
        font-size: 11px;
        font-weight: bold;
        border-radius: 50%;
        padding: 2px 5px;
        display: none;
        transition: transform 0.2s ease;
        border: 1px solid white;
      }
      .comment-badge.pulse {
        transform: scale(1.25);
      }

      /* === Counter & Pill Buttons === */
      #counter {
        margin-bottom: 15px;
        font-weight: 500;
        color: var(--lufthansa-text-light);
      }
      #counter .highlight {
        color: var(--lufthansa-blue);
        font-weight: 600;
      }
      .pill-btn {
        display: inline-block;
        margin-top: 8px;
        margin-bottom: 12px;
        padding: 6px 14px;
        font-size: 13px;
        font-weight: 500;
        background: var(--lufthansa-card-bg);
        border: 1px solid var(--lufthansa-border);
        border-radius: 20px;
        cursor: pointer;
        transition: all 0.2s ease;
        margin-right: 8px;
      }
      .pill-btn:hover {
        background: #f1f3f5;
      }
      .pill-btn.active {
        background: var(--lufthansa-blue);
        color: white;
        border-color: var(--lufthansa-blue);
      }
      .printable {
        margin-top: 10px;
        font-size: 14px;
        background: #6c757d;
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: var(--lufthansa-radius);
        cursor: pointer;
      }
      .logbook-btn {
        background-color: var(--lufthansa-blue);
        color: #fff;
        border: none;
        padding: 8px 16px;
        margin-left: 8px;
        border-radius: var(--lufthansa-radius);
        cursor: pointer;
        font-weight: 500;
        transition: background 0.3s;
      }
      .logbook-btn:hover {
        background-color: #0a267c;
      }

      /* === Main Layout (Tables & Charts) === */
      .layout {
        display: flex;
        gap: 20px;
        align-items: flex-start;
        flex-wrap: wrap;
      }
      /* Moved inline styles to CSS */
      #phaseTotalsWrapper {
        display: flex;
        flex-wrap: wrap;
        gap: 20px;
        align-items: flex-start;
        width: 100%; /* Ensure it takes full width to wrap children */
      }
      #phaseTotalsContainer {
        flex: 1 1 400px;
        min-width: 300px;
      }
      #phaseChartContainer,
      #jcChartContainer {
        flex: 1 1 300px;
        min-width: 250px;
        background: var(--lufthansa-card-bg);
        border: 1px solid var(--lufthansa-border);
        border-radius: var(--lufthansa-radius);
        padding: 10px;
      }
      #jcChartContainer {
        height: 270px; /* Give jcChart a bit more space */
      }
      #phaseChartContainer {
        height: 270px;
      }

      /* === Main Data Table === */
      #scrollArea {
        flex: 1;
        width: 100%;
        height: 500px;
        overflow-y: auto;
        border: 1px solid var(--lufthansa-border);
        background: var(--lufthansa-card-bg);
        border-radius: var(--lufthansa-radius);
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
      }
      table {
        width: 100%;
        border-collapse: collapse;
        table-layout: fixed;
      }
      th,
      td {
        padding: 6px;
        border: 1px solid var(--lufthansa-border);
        font-size: 14px;
        text-align: left;
        overflow: hidden;
      }
      thead th {
        background: #f1f3f5;
        position: sticky;
        top: 0;
        z-index: 2;
        padding: 8px 6px;
      }
      thead input {
        width: 95%;
        padding: 4px 6px;
        font-size: 12px;
        box-sizing: border-box;
        border-radius: 6px;
        border: 1px solid #ced4da;
      }

      /* === Specific Table Overrides === */
      #phaseTotalsTable {
        width: 100%;
        border-collapse: collapse;
        background: var(--lufthansa-card-bg);
        border-radius: var(--lufthansa-radius);
        border: 1px solid var(--lufthansa-border);
        overflow: hidden;
      }
      #phaseTotalsTable th,
      #phaseTotalsTable td {
        border: 1px solid var(--lufthansa-border);
        font-size: 12px;
        padding: 4px 6px;
      }
      #phaseTotalsTable th {
        background: #f1f3f5;
      }
      #scrollArea th,
      #scrollArea td {
        font-size: 11px;
        padding: 2px 4px;
      }
      #scrollArea thead input {
        font-size: 11px;
        padding: 2px 4px;
        height: 20px;
      }
      #clearSeqBtn {
        display: none;
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        border: none;
        background: transparent;
        cursor: pointer;
        font-size: 14px;
        color: var(--lufthansa-danger);
        padding: 0;
        line-height: 1;
      }
      .cmnt-btn {
        display: flex;
        margin-top: 2px;
        margin-bottom: 2px;
        padding: 2px 7px;
        font-size: 11px;
        font-weight: 500;
        background: #f1f3f5;
        border: 1px solid var(--lufthansa-border);
        border-radius: 20px;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .cmnt-btn:hover {
        background: #e9ecef;
      }
      .comment-cell {
        vertical-align: top;
        border: 1px solid var(--lufthansa-border);
        padding: 2px 6px;
      }
      .comment-input {
        width: 100%;
        border: none;
        outline: none;
        background: transparent;
        font-size: 13px;
        font-family: inherit;
        line-height: 1.3;
        resize: none;
        overflow: hidden;
        padding: 2px 4px;
        box-sizing: border-box;
        min-height: 18px;
      }
      .comment-input:focus {
        background-color: #f5f5f5;
      }

      /* === History Panel === */
      h3 {
        font-size: 1rem;
        padding: 6px 0;
        margin-top: 0;
        color: var(--lufthansa-blue);
        font-weight: 600;
      }
      .history-list-scroll {
        flex-grow: 1; /* üëà Replaces height: 80vh */
        min-height: 0; /* üëà Add this for flex stability */
        overflow-y: auto;
        border: 1px solid var(--lufthansa-border);
        border-radius: var(--lufthansa-radius);
        background: #fff;
      }
      .history-list {
        list-style: none;
        padding: 0;
        margin: 0;
        max-height: none;
        overflow-y: visible;
        font-family: monospace;
        font-size: 13px;
      }
      .history-list li {
        border-bottom: 1px solid #eee;
        padding: 8px 10px;
        line-height: 1.5;
      }
      .history-list li span.time {
        color: #777;
        font-size: 12px;
      }
      .history-list li span.status {
        font-weight: bold;
      }
      .history-list li span.closed {
        color: var(--lufthansa-success);
      }
      .history-list li span.open {
        color: var(--lufthansa-danger);
      }
      .history-list li span.modified {
        color: var(--lufthansa-text-light);
      }

      /* === Loading Overlay === */
      #loadingOverlay {
        position: fixed;
        inset: 0;
        background: rgba(255, 255, 255, 0.8);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        font-size: 18px;
        color: var(--lufthansa-text);
        opacity: 1;
        transition: opacity 0.5s ease;
      }
      #loadingOverlay.hidden {
        opacity: 0;
        pointer-events: none;
      }
      #loadingOverlay .spinner {
        border: 4px solid #ccc;
        border-top: 4px solid var(--lufthansa-blue);
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin-bottom: 10px;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* === Scan Modal === */
      #scanModal {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.6);
        align-items: center;
        justify-content: center;
        z-index: 10000;
      }
      #scanModal .modal-content {
        background: var(--lufthansa-card-bg);
        padding: 20px;
        border-radius: 12px;
        width: 1000px;
        max-width: 1200px;
        max-height: 80vh;
        overflow: auto;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      }
      #scanModal h3 {
        color: var(--lufthansa-blue);
        margin: 0 0 8px;
      }
      #manualInputContainer {
        margin-top: 10px;
        display: flex;
        gap: 8px;
      }
      #manualInputContainer input {
        flex-grow: 1;
        padding: 6px 10px;
        border: 1px solid var(--lufthansa-border);
        border-radius: var(--lufthansa-radius);
      }
      #manualInputContainer button {
        background: var(--lufthansa-blue);
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: var(--lufthansa-radius);
        cursor: pointer;
      }
      .scan-table {
        width: 100%;
        border-collapse: collapse;
        font-size: 13px;
        margin-top: 6px;
      }
      .scan-table th,
      .scan-table td {
        border: 1px solid var(--lufthansa-border);
        padding: 6px 8px;
        text-align: center;
      }
      .scan-table th {
        background: #f1f3f5;
        font-weight: bold;
      }
      .scan-table td button {
        padding: 3px 6px;
        font-size: 12px;
        cursor: pointer;
        border-radius: 4px;
        border: none;
        color: white;
        background: var(--lufthansa-success);
      }
      .scan-table td button[data-reopen] {
        background: var(--lufthansa-yellow);
        color: var(--lufthansa-blue);
      }
      .scan-table td button[data-remove] {
        background: var(--lufthansa-danger);
      }
      .pill {
        font-size: 12px;
        padding: 2px 8px;
        background: #e9ecef;
        border-radius: 10px;
        color: var(--lufthansa-text-light);
        display: inline-block;
        font-weight: 500;
      }
      .modal-actions {
        display: flex;
        gap: 8px;
        margin-top: 16px;
        justify-content: flex-end;
      }
      #submitScanBtn {
        background: var(--lufthansa-success);
      }
      #clearScanBtn {
        background: #6c757d;
      }
      #closeScanBtn {
        background: var(--lufthansa-danger);
      }

      /* Hidden barcode input */
      #barcodeInput {
        position: absolute;
        left: -9999px;
        top: -9999px;
      }

      /* === Toast Notifications === */
      #toastContainer {
        position: fixed;
        top: 20px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 11000;
      }
      .toast {
        background: var(--lufthansa-text);
        color: #fff;
        padding: 12px 18px;
        border-radius: var(--lufthansa-radius);
        font-size: 14px;
        font-weight: 500;
        opacity: 0;
        transform: translateX(100%);
        transition: all 0.4s ease;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }
      .toast.show {
        opacity: 1;
        transform: translateX(0);
      }
      .toast.success {
        background: var(--lufthansa-success);
      }
      .toast.error {
        background: var(--lufthansa-danger);
      }
      .toast.info {
        background: var(--lufthansa-blue);
      }

      /* === Toggle Switch === */
      .switch {
        position: relative;
        display: inline-block;
        width: 30px;
        height: 12px;
        vertical-align: middle;
      }
      .switch input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      .slider {
        position: absolute;
        cursor: pointer;
        inset: 0;
        background-color: #ccc;
        transition: 0.4s;
        border-radius: 10px;
      }
      .slider:before {
        position: absolute;
        content: "";
        height: 10px;
        width: 10px;
        left: 1px;
        bottom: 1px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
        box-shadow: 0 1px 1px rgba(0, 0, 0, 0.1);
      }
      input:checked + .slider {
        background-color: var(--lufthansa-success);
      }
      input:checked + .slider:before {
        transform: translateX(18px);
      }

      /* === History Glow Effects === */
      @keyframes pulseGlowGreen {
        0%,
        100% {
          background-color: #e8f5e9;
          box-shadow: 0 0 10px 2px #81c784;
        }
        50% {
          background-color: #c8e6c9;
          box-shadow: 0 0 20px 5px #66bb6a;
        }
      }
      .pulse-glow-green {
        animation: pulseGlowGreen 1.8s ease-in-out infinite;
      }
      @keyframes pulseGlowBlue {
        0%,
        100% {
          background-color: #fde8e3;
          box-shadow: 0 0 10px 2px #f66464;
        }
        50% {
          background-color: #fbbbbb;
          box-shadow: 0 0 20px 5px #f54242;
        }
      }
      .pulse-glow-blue {
        animation: pulseGlowBlue 1.8s ease-in-out infinite;
      }
      @keyframes pulseGlowAmber {
        0%,
        100% {
          background-color: #fff8e1;
          box-shadow: 0 0 10px 2px #ffca28;
        }
        50% {
          background-color: #ffecb3;
          box-shadow: 0 0 20px 5px #ffc107;
        }
      }
      .pulse-glow-amber {
        animation: pulseGlowAmber 1.8s ease-in-out infinite;
      }

      /* === Responsive (Merged) === */
      @media (max-width: 900px) {
        body {
          margin: 0;
        }
        .plan-header {
          margin-bottom: 10px;
          padding: 10px;
        }
        .plan-heading {
          font-size: 1rem;
        }
        .main-wrapper {
          flex-direction: column;
          padding: 0 10px 10px;
        }
        .history {
          width: 100%;
          max-width: none;
          box-sizing: border-box;
        }
        .layout {
          flex-direction: column;
        }
        .left-column,
        #scrollArea {
          flex: 1 1 100%;
          max-width: 100%;
        }
        #phaseTotalsContainer {
          max-width: 100%;
          width: 100%;
        }
        #phaseChartContainer,
        #jcChartContainer {
          width: 100%;
          box-sizing: border-box;
        }
      }
      /* Example CSS - add this to your main stylesheet */
      .notification-badge {
        background-color: var(--lufthansa-danger, #e53935);
        color: white;
        border-radius: 10px;
        padding: 2px 7px;
        font-size: 11px;
        font-weight: bold;
        line-height: 1;
        display: inline-block;
        vertical-align: top;
        margin-left: 8px;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div class="plan-header">
      <div class="plan-heading" id="dynamicHeader">No Data</div>
      <span id="lastUpdate" class="liveUpdate"></span>
      <button onclick="logout()" class="logout-btn">Logout</button>
    </div>

    <div class="main-wrapper">
      <!-- Left side main content -->
      <div class="main-content">
        <div class="controls">
          <input type="text" id="woInput" placeholder="Enter Workorder" />
          <button class="btn" id="woSearchBtn">Search</button>

          <button
            class="btn"
            id="startScanBtn"
            title="Activate barcode scanner"
          >
            Scan Here!
          </button>
          <button
            class="btn"
            id="stopScanBtn"
            title="Stop scanner"
            style="display: none"
          >
            Stop Scan
          </button>

          <!-- Hidden input to capture scanner keystrokes -->
          <label for="barcodeInput" style="display: none">Barcode Input</label>
          <input
            type="text"
            id="barcodeInput"
            name="barcodeInput"
            autocomplete="off"
            placeholder="Scan or enter barcode"
            title="Scan or enter barcode here"
          />
        </div>

        <div class="skill-filters">
          <button data-skill="CLEAR" class="active">
            ALL SKILL
            <span class="comment-badge" data-skill="CLEAR">0</span>
          </button>
          <button data-skill="GEN">
            GEN
            <span class="comment-badge" data-skill="GEN">0</span>
          </button>
          <button data-skill="AVI">
            AVI
            <span class="comment-badge" data-skill="AVI">0</span>
          </button>
          <button data-skill="CRG/ENG">
            CRG/ENG
            <span class="comment-badge" data-skill="CRG/ENG">0</span>
          </button>
          <button data-skill="CAB">
            CAB
            <span class="comment-badge" data-skill="CAB">0</span>
          </button>
          <button data-skill="LDG/FLC">
            LDG/FLC
            <span class="comment-badge" data-skill="LDG/FLC">0</span>
          </button>
          <button data-skill="STR">
            STR
            <span class="comment-badge" data-skill="STR">0</span>
          </button>
        </div>

        <div id="counter">Waiting for input...</div>
        <button id="multiSkillBtn" class="pill-btn">Multiskill MTC</button>
        <button id="singleSkillBtn" class="pill-btn">Single Skill MTC</button>

        <div class="layout">
          <!-- Phase totals and chart (responsive side-by-side) -->
          <!-- STYLES MOVED TO CSS -->
          <div id="phaseTotalsWrapper">
            <!-- üìä Phase Table -->
            <div id="phaseTotalsContainer">
              <table
                id="phaseTotalsTable"
                style="width: 100%; border-collapse: collapse"
              >
                <thead>
                  <tr>
                    <th>Phase</th>
                    <th style="text-align: right">Open Tasks</th>
                    <th style="text-align: right">Closed Tasks</th>
                    <th style="text-align: right">Cancelled Tasks</th>
                    <th style="text-align: right">Hold Tasks</th>
                    <th style="text-align: right">% Closed</th>
                  </tr>
                </thead>
                <tbody id="phaseTotalsBody">
                  <tr>
                    <td colspan="6" style="text-align: center">No data</td>
                  </tr>
                </tbody>
              </table>
            </div>

            <div id="phaseChartContainer">
              <canvas id="phaseChart"></canvas>
            </div>

            <div id="jcChartContainer">
              <canvas id="jcChart"></canvas>
            </div>
          </div>
          <!-- hidden badge container -->
          <div id="dynamicBadgeContainer" style="display: none"></div>
          <!-- Main scrollable table -->
          <div id="scrollArea">
            <table>
              <thead>
                <tr>
                  <th style="width: 160px">Reference</th>
                  <th>Description</th>
                  <th style="width: 50px">Seq.No</th>
                  <th style="width: 70px">Status</th>
                  <th style="width: 160px">TaskCard Items</th>
                  <th style="width: 160px">Comments</th>
                  <th style="width: 40px"></th>
                  <th style="width: 40px"></th>
                  <th style="width: 40px"></th>
                  <th style="width: 40px"></th>
                  <th style="width: 40px"></th>
                  <th style="width: 40px"></th>
                  <th style="width: 40px"></th>
                </tr>
                <tr>
                  <th>
                    <input
                      type="text"
                      class="filter"
                      data-field="reference_task_card"
                      placeholder="Search Reference"
                    />
                  </th>
                  <th>
                    <input
                      type="text"
                      class="filter"
                      data-field="task_card_description"
                      placeholder="Search Description"
                    />
                  </th>
                  <th style="position: relative">
                    <input
                      type="text"
                      class="filter"
                      data-field="seq"
                      placeholder="Search Seq"
                      style="padding-right: 18px"
                    />
                    <!-- STYLE MOVED TO CSS -->
                    <button id="clearSeqBtn">‚úñ</button>
                  </th>
                  <th>
                    <input
                      type="text"
                      class="filter"
                      data-field="status"
                      placeholder="Search Status"
                    />
                  </th>
                  <th>
                    <input
                      type="text"
                      class="filter"
                      data-field="task_card"
                      placeholder="Search TaskCard Items"
                    />
                  </th>
                  <th>
                    <button id="manualTrigger" class="cmnt-btn">
                      All Comments
                    </button>
                  </th>
                  <th>PH</th>
                  <th>P1</th>
                  <th>P2</th>
                  <th>P3</th>
                  <th>P4</th>
                  <th>P6</th>
                  <th>P0</th>
                </tr>
              </thead>
              <tbody id="contentArea" class="clusterize-content">
                <tr class="clusterize-no-data">
                  <td colspan="12">No data yet</td>
                </tr>
              </tbody>
            </table>
          </div>
        </div>
        <button onclick="printFullTable()" class="printable">
          üñ®Ô∏è Print This Table
        </button>
        <button id="logbookBtn" class="logbook-btn">Turnover Logbook</button>

    <button 
      id="dashboardToggleBtn" 
      class="logbook-btn" 
      style="background-color: var(--lufthansa-yellow); color: var(--lufthansa-blue);"
      onclick="window.open('discrepant.html', '_blank')"
    >
      Discrepant Dashboard
    </button>
        
        <!-- Scan Modal -->
        <div
          id="scanModal"
          role="dialog"
          aria-modal="true"
          aria-labelledby="scanModalTitle"
        >
          <div class="modal-content">
            <h3 id="scanModalTitle">Scanned Sequences</h3>
            <div style="font-size: 12px; color: #555">
              WO: <span id="activeWO" class="pill">‚Äî</span> ‚Ä¢ Count:
              <span id="scanCount" class="pill">0</span>
              <span style="padding-left: 20px; float: right">
                <label
                  class="switch"
                  style="margin-right: 8px"
                  title="Toggle to show/hide already closed tasks"
                >
                  <input type="checkbox" id="showClosedChk" />
                  <span class="slider round"></span>
                </label>
                <span> Re-open Task Item(s)</span>
              </span>
            </div>

            <!-- Manual input for seq number -->
            <div id="manualInputContainer">
              <label for="manualSeqInput" style="display: none">
                Manual Seq Number
              </label>
              <input
                type="number"
                id="manualSeqInput"
                name="manualSeqInput"
                placeholder="Enter Seq Number"
                title="Enter sequence number manually"
              />
              <button id="manualAddBtn" title="Add entered sequence number">
                Add
              </button>
            </div>

            <!-- Search results for scanned/typed seq -->
            <div style="margin-top: 10px">
              <h4 style="font-size: 13px; margin-bottom: 5px; color: #444">
                Matching Tasks
              </h4>
              <table class="scan-table">
                <thead>
                  <tr>
                    <th>Seq</th>
                    <th>Task Items</th>
                    <th>Phase</th>
                    <th>Skill</th>
                    <th>Status</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody id="scanResultsList"></tbody>
              </table>
            </div>

            <!-- Queue of tasks to close -->
            <div style="margin-top: 15px">
              <h4 style="font-size: 13px; margin-bottom: 5px; color: #444">
                Queued Tasks
              </h4>
              <table class="scan-table">
                <thead>
                  <tr>
                    <th>Seq</th>
                    <th>Task Items</th>
                    <th>Phase</th>
                    <th>Skill</th>
                    <th>Status</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody id="scannedList"></tbody>
              </table>
            </div>

            <div class="modal-actions">
              <button
                class="btn"
                id="submitScanBtn"
                title="Update queued tasks to CLOSED"
              >
                Submit
              </button>
              <button class="btn" id="clearScanBtn" title="Clear list">
                Clear
              </button>
              <button class="btn" id="closeScanBtn" title="Close modal">
                Close
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Right side history panel -->
      <div class="history" id="historyPanel">
        <h3
          style="
            display: flex;
            justify-content: space-between;
            align-items: center;
          "
        >
          <div>
            Updates
            <span
              id="historyBadge"
              class="notification-badge"
              style="display: none"
            ></span>
          </div>

          <button
            id="clearNotifBtn"
            class="pill-btn"
            style="margin: 0; padding: 4px 10px; font-size: 12px"
          >
            Clear Notifications
          </button>
        </h3>

        <div id="historyScrollArea" class="history-list-scroll">
          <ul id="historyList" class="history-list">
            <li class="clusterize-no-data">Waiting for updates...</li>
          </ul>
        </div>
      </div>
    </div>
    <!-- Loading -->
    <div id="loadingOverlay">
      <div class="spinner"></div>
      <div>Loading, please wait...</div>
    </div>
    <!-- Toast Notifications -->
    <div id="toastContainer"></div>

    <script src="https://cdn.jsdelivr.net/npm/clusterize.js@0.18.1/clusterize.min.js"></script>
    <script type="module">
      // Updated to 10.12.2 for consistency
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
      import {
        getFirestore,
        collection,
        onSnapshot,
        query,
        where,
        doc,
        getDoc,
        updateDoc,
        getDocs,
        orderBy,
        limit,
        addDoc,
        serverTimestamp,
      } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
      import {
        getAuth,
        onAuthStateChanged,
        signOut,
      } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";
      /* =======================
        Firebase Init
      ======================== */
      const firebaseConfig = {
        apiKey: "AIzaSyDCpHhUL8x4rs-fom1xyaNdWm5prSGf57U",
        authDomain: "onemtc-2222c.firebaseapp.com",
        projectId: "onemtc-2222c",
        storageBucket: "onemtc-2222c.firebasestorage.app",
        messagingSenderId: "447271556426",
        appId: "1:447271556426:web:562ba4d72e40b754599db3",
      };
      const app = initializeApp(firebaseConfig);
      const db = getFirestore(app);
      const auth = getAuth(app);
      // REMOVED commented-out signInAnonymously

      // ‚úÖ ADDED Global logout function
      window.logout = function () {
        signOut(auth)
          .then(() => {
            console.log("User signed out.");
            localStorage.removeItem("lastWorkorder"); // Clear session
            window.location.href = "index.html"; // Ensure full page name
          })
          .catch((error) => {
            console.error("Sign out error", error);
          });
      };

      // ‚úÖ COMBINED Auth Listeners
      let loginUser = "Unknown"; // Global state
      onAuthStateChanged(auth, (user) => {
        if (!user) {
          console.log("‚ö†Ô∏è No user signed in. Redirecting to login...");
          loginUser = "Unknown"; // Reset on logout
          window.location.href = "index.html";
        } else {
          // User is signed in
          console.log(`‚úÖ Logged in as: ${user.email || "Anonymous"}`);

          // Set loginUser
          if (user.email) {
            loginUser = user.email.includes("@")
              ? user.email.split("@")[0]
              : user.email;
          } else {
            loginUser = "Anonymous";
          }

          // This element doesn't seem to exist, but logic is harmless
          const userDisplay = document.getElementById("userDisplay");
          if (userDisplay) userDisplay.textContent = user.email || "Anonymous";
        }
      });

      function debounce(func, wait) {
        let timeout;
        return function (...args) {
          const context = this;
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(context, args), wait);
        };
      }
      /* =======================
        UI refs
      ======================== */
      // Create a debounced version of applyFilters
      const debouncedApplyFilters = debounce(applyFilters, 300); // 300ms delay
      const counterEl = document.getElementById("counter");
      const woInput = document.getElementById("woInput");
      const woSearchBtn = document.getElementById("woSearchBtn");
      const overlay = document.getElementById("loadingOverlay");

      const startScanBtn = document.getElementById("startScanBtn");
      const stopScanBtn = document.getElementById("stopScanBtn");
      const barcodeInput = document.getElementById("barcodeInput");

      const scanModal = document.getElementById("scanModal");
      const scannedList = document.getElementById("scannedList"); // ‚úÖ REMOVED duplicate
      const submitScanBtn = document.getElementById("submitScanBtn");
      const clearScanBtn = document.getElementById("clearScanBtn");
      const closeScanBtn = document.getElementById("closeScanBtn");
      const activeWOEl = document.getElementById("activeWO");
      const scanCountEl = document.getElementById("scanCount");
      const fixedPhases = ["PH", "P1", "P2", "P3", "P4", "P6", "P0"];
      const lastUpdateEl = document.getElementById("lastUpdate");
      const showClosedChk = document.getElementById("showClosedChk");
      const historyListEl = document.getElementById("historyList");
      /* =======================
        Clusterize Table
      ======================== */
      const clusterize = new Clusterize({
        scrollId: "scrollArea",
        contentId: "contentArea",
        rows: [],
      });
      // üëá ADD THIS NEW INSTANCE
      const historyClusterize = new Clusterize({
        scrollId: "historyScrollArea", // üëà The new scroll container
        contentId: "historyList", // üëà The <ul>
        rows: [],
        no_data_text: "No history yet...",
        item_height: 85, // üëà (Optional) Guessing your <li> height, adjust if needed
        tag: "li",
      });
      /* =======================
        State
      ======================== */
      let unsubscribe = null;
      let allDocs = []; // all docs for current WO
      let allHistoryData = []; // üëà Add this line
      let newHistoryItems = [];
      let activeSkill = "CLEAR";
      let scanningActive = false;
      let scannedSeqs = []; // numbers only
      let currentWO = null; // string or number (as searched)
      let seqFilterValues = []; // listahan ng lahat ng in-enter na seq filters
      let activePhase = null; // currently selected phase filter
      let multiSkillActive = false;
      let singleSkillActive = false;
      function getClosedPercentage(docs) {
        if (!docs.length) return 0;
        const closedCount = docs.filter((d) => {
          const st = (d.status || "").toLowerCase();
          return st === "closed" || st === "cancel";
        }).length;
        return ((closedCount / docs.length) * 100).toFixed(1);
      }

      /* =======================
        History Realtime Listener
      ======================= */
      window.addEventListener("load", () => {
        const lastWO = localStorage.getItem("lastWorkorder");
        if (lastWO) {
          //console.log("üîÑ Restoring last WO:", lastWO);
          document.getElementById("woInput").value = lastWO;

          // üîπ Load tasks
          searchWorkorder(lastWO);

          // üîπ Load matching history
          listenToHistoryForWO(lastWO);
        } else {
          console.log("‚ÑπÔ∏è No previous Work Order found");
        }
      });

      let unsubscribeHistory = null; // store listener cleanup reference

      function listenToHistoryForWO(workorder) {
        if (unsubscribeHistory) {
          unsubscribeHistory();
          unsubscribeHistory = null;
        }
        const workorderValue = isNaN(workorder) ? workorder : Number(workorder);
        const badgeData = JSON.parse(
          localStorage.getItem("historyBadgeData") || "{}"
        ); // Check if the stored WO matches the one we are loading

        if (badgeData.wo === workorderValue) {
          // It matches, so load the saved items
          newHistoryItems = badgeData.items || [];
        } else {
          // It's a new WO, so reset the counter
          newHistoryItems = [];
        }
        updateHistoryBadge(); // Update display with loaded (or cleared) data

        // ‚úÖ FIXED: Use clusterize.update to show loading, not innerHTML
        historyClusterize.update([
          `<li class='clusterize-no-data'>Loading history for ${workorder}...</li>`,
        ]);

        const qHistory = query(
          collection(db, "history"),
          where("wo", "==", workorderValue),
          orderBy("timestamp", "desc")
        );

        let initialLoad = true;

        unsubscribeHistory = onSnapshot(
          qHistory,
          (snapshot) => {
            if (snapshot.empty) {
              historyClusterize.update([
                "<li class='clusterize-no-data'>No history yet...</li>",
              ]);
              return;
            }

            if (initialLoad) {
              // 1. Build the array of <li> strings
              allHistoryData = snapshot.docs.map((docSnap) => {
                return renderHistoryItem(docSnap.data(), docSnap.id); // üëà Pass data and id
              });

              // 2. Update Clusterize with the full list
              historyClusterize.update(allHistoryData);

              // 3. Call your other functions after the list is rendered
              restoreGlow();
              renderJCChart(currentWO || workorder, allDocs);

              initialLoad = false;
              return;
            }

            // üîπ After first load: handle live changes
            snapshot.docChanges().forEach((change) => {
              const data = change.doc.data();
              const id = change.doc.id;
              if (change.type === "added") {
                // 1. Render the new <li> string
                const liString = renderHistoryItem(data, id);

                // 2. Add to our state array
                allHistoryData.unshift(liString); // Add to the beginning

                // 3. Prepend to Clusterize
                historyClusterize.prepend([liString]);

                // 4. üîΩ NEW BADGE LOGIC (replaces all glow logic) üîΩ

                // Only count items if this isn't the first, initial load
                if (!initialLoad) {
                  newHistoryItems.push(id);
                  updateHistoryBadge();
                }
              }

              if (change.type === "removed") {
                // Find and remove from state array
                allHistoryData = allHistoryData.filter((rowString) => {
                  return !rowString.includes(`data-id="${id}"`);
                });
                // Refresh the whole list in Clusterize
                historyClusterize.update(allHistoryData);
              }
            });
          },
          (error) => {
            console.error("‚ùå History listener error:", error);
            historyClusterize.update([
              "<li class='clusterize-no-data'>Error loading history</li>",
            ]);
          }
        );

        // üßπ Helper: remove all glowing states
        function clearGlow() {
          document
            .querySelectorAll(".pulse-glow")
            .forEach((el) => el.classList.remove("pulse-glow"));
        }

        // üñ±Ô∏è Remove glow on user interaction
        const removeGlowOnUserAction = () => {
          clearGlow();
          document.removeEventListener("click", removeGlowOnUserAction);
          document.removeEventListener("keydown", removeGlowOnUserAction);
          document.removeEventListener("scroll", removeGlowOnUserAction);
        };

        document.addEventListener("click", removeGlowOnUserAction);
        document.addEventListener("keydown", removeGlowOnUserAction);
        document.addEventListener("scroll", removeGlowOnUserAction);
      }
      function clearGlow() {
        document
          .querySelectorAll(
            ".pulse-glow-green, .pulse-glow-blue, .pulse-glow-amber"
          )
          .forEach((el) => {
            el.classList.remove(
              "pulse-glow-green",
              "pulse-glow-blue",
              "pulse-glow-amber"
            );
          });
      }
      document.getElementById("clearNotifBtn").addEventListener("click", () => {
        clearGlow();
        clearGlowState();
      });

      function saveGlowState(id, glowClass) {
        const glowData = JSON.parse(localStorage.getItem("glowState") || "{}");
        glowData[id] = glowClass;
        localStorage.setItem("glowState", JSON.stringify(glowData));
      }

      function loadGlowState() {
        return JSON.parse(localStorage.getItem("glowState") || "{}");
      }

      function clearGlowState() {
        localStorage.removeItem("glowState");
      }

      function restoreGlow() {
        const glowData = loadGlowState();
        for (const [id, glowClass] of Object.entries(glowData)) {
          const li = document.querySelector(`[data-id="${id}"]`);
          if (li) li.classList.add(glowClass);
        }
      }

      document.getElementById("woSearchBtn").addEventListener("click", () => {
        const wo = document.getElementById("woInput").value.trim();
        if (!wo) {
          showToast("Please enter a Work Order", "error");
          return;
        }

        // Load tasks for this WO (your existing function)
        searchWorkorder(wo);

        // Start listening to history for this WO
        listenToHistoryForWO(wo);
      });

      function renderHistoryItem(data, id) {
        // üëà Note the new "id" parameter
        const time = data.timestamp?.toDate
          ? data.timestamp.toDate().toLocaleString()
          : "No time";
        const seq = data.seq ?? "N/A";
        const skill = data.skill ?? "N/A";
        const phase = data.phase ?? "N/A";
        const task = data.task_card ?? "Unknown";
        const status = (data.status ?? "N/A").toUpperCase();

        let modifiedBy = data.modified_by ?? "Unknown";
        if (modifiedBy.includes("@")) {
          modifiedBy = modifiedBy.split("@")[0];
        }

        // üëá This is the change: return a string, not an element
        return `
    <li data-id="${id}"> 
  <span class="time">${time}</span><br>
  <strong>Seq ${seq}</strong> ‚Äî ${task}<br>
  <span class="tag skill">Skill: ${skill}</span> ‚Ä¢ 
  <span class="tag phase">Phase: ${phase}</span><br>
  <span class="status ${status === "CLOSED" ? "closed" : "open"}">
    Item ${parseInt(task.split('-').pop(), 10)} ${
    status === "OPEN"
      ? "RE-OPEN"
      : status === "CLOSED"
      ? "COMPLETED"
      : status
  }
  </span> 
  <span class="time"><small>by ${modifiedBy}</small></span>
</li>
  `;
      }

      async function logHistoryEntry(task, newStatus) {
        try {
          const user = auth.currentUser;
          // Use the global loginUser variable
          const modifiedBy = loginUser || "Unknown";

          await addDoc(collection(db, "history"), {
            wo: task.wo || "N/A",
            seq: task.seq || "N/A",
            skill: task.skill || "N/A",
            phase: task.phase || "N/A",
            task_card: task.task_card || "N/A",
            status: newStatus,
            modified_by: modifiedBy, // Use the cleaned username
            timestamp: serverTimestamp(),
          });

          console.log(
            `‚úÖ History logged by ${modifiedBy}:`,
            task.task_card,
            newStatus
          );
        } catch (err) {
          console.error("‚ùå Error logging history:", err);
        }
      }

      /* =======================
        Helpers
      ======================== */
      /**
       * Updates the history notification badge with the current count.
       */
      function updateHistoryBadge() {
        const badge = document.getElementById("historyBadge");
        if (!badge) return; // Failsafe if HTML is not ready

        const count = newHistoryItems.length;

        if (count > 0) {
          badge.textContent = count;
          badge.style.display = "inline-block";
        } else {
          badge.style.display = "none";
          badge.textContent = "";
        }
        const badgeData = {
          wo: currentWO, // The globally stored work order
          items: newHistoryItems,
        };
        localStorage.setItem("historyBadgeData", JSON.stringify(badgeData));
      }

      function calculateDayProgress(startDate, endDate, wo, filterWo) {
        if (filterWo && wo !== filterWo) return ""; // üö´ Skip if WO doesn‚Äôt match
        if (!startDate || !endDate) return "";

        // ‚ú® FIX: Helper to safely parse dates in the LOCAL timezone
        const parseDateAsLocal = (dateInput) => {
          if (dateInput.toDate) {
            return dateInput.toDate(); // Handle Firestore Timestamps
          }
          if (
            typeof dateInput === "string" &&
            dateInput.match(/^\d{4}-\d{2}-\d{2}$/)
          ) {
            return new Date(`${dateInput}T00:00:00`);
          }
          return new Date(dateInput);
        };

        const start = parseDateAsLocal(startDate);
        const end = parseDateAsLocal(endDate);
        const today = new Date();

        if (isNaN(start.getTime()) || isNaN(end.getTime())) return "";

        start.setHours(0, 0, 0, 0);
        end.setHours(0, 0, 0, 0);
        today.setHours(0, 0, 0, 0);

        const msPerDay = 1000 * 60 * 60 * 24;

        const totalDays =
          Math.round((end.getTime() - start.getTime()) / msPerDay) + 1;

        if (totalDays <= 0) return "";

        if (today.getTime() < start.getTime()) {
          const formattedStart = start.toLocaleDateString("en-US", {
            month: "short",
            day: "numeric",
            year: "numeric",
          });
          return `Start date is on ${formattedStart}`;
        } else if (today.getTime() > end.getTime()) {
          return `Completed (${totalDays} days total)`;
        } else {
          const currentDay =
            Math.round((today.getTime() - start.getTime()) / msPerDay) + 1;
          return `Day ${currentDay} of ${totalDays}`;
        }
      }
      const showLoading = () => {
        overlay.classList.remove("hidden");
        overlay.style.display = "flex";
      };
      const hideLoading = () => {
        overlay.classList.add("hidden");
        // We use 'hidden' class to fade out, then display:none is set by animation
        setTimeout(() => {
          if (overlay.classList.contains("hidden")) {
            overlay.style.display = "none";
          }
        }, 500); // Match transition duration
      };

      // PRINTING......

      function printFullTable() {
        if (!allDocs || allDocs.length === 0) {
          showToast("No data to print ‚ùó", "error");
          return;
        }

        let filteredDocs = [...allDocs];
        // ==========================================================
        // 1) MULTI-SKILL and SINGLE-SKILL FILTER (MUST COME FIRST)
        // ==========================================================

        // Build map: seq ‚Üí unique skills
        const seqSkillMap = {};
        allDocs.forEach((d) => {
          const seq = String(d.seq);
          if (!seqSkillMap[seq]) seqSkillMap[seq] = new Set();
          if (d.skill) seqSkillMap[seq].add(d.skill);
        });

        // --- MULTI-SKILL MODE ---
        if (multiSkillActive) {
          filteredDocs = filteredDocs.filter((d) => {
            const sz = seqSkillMap[String(d.seq)]?.size || 0;
            return sz > 1; // keep seqs with more than 1 skill
          });

          // highlight
          filteredDocs = filteredDocs.map((d) => ({
            ...d,
            highlightTask: true,
          }));
        }

        // --- SINGLE-SKILL MODE ---
        else if (singleSkillActive) {
          filteredDocs = filteredDocs.filter((d) => {
            const sz = seqSkillMap[String(d.seq)]?.size || 0;
            return sz === 1; // keep seqs with only 1 skill
          });

          filteredDocs = filteredDocs.map((d) => ({
            ...d,
            highlightTask: true,
          }));
        }

        // Skill filter (clean version)
        if (activeSkill !== "CLEAR") {
          // If grouped skills (example: AVI includes AVI1, AVI2)
          if (skillGroups[activeSkill]) {
            filteredDocs = filteredDocs.filter((d) =>
              skillGroups[activeSkill].includes(d.skill)
            );
          }

          // Single skill
          else {
            filteredDocs = filteredDocs.filter((d) => d.skill === activeSkill);
          }

          // Highlight all tasks that remain
          filteredDocs = filteredDocs.map((d) => ({
            ...d,
            highlightTask: true,
          }));
        }

        if (seqFilterValues && seqFilterValues.length > 0) {
          filteredDocs = filteredDocs.filter((d) =>
            seqFilterValues.includes(String(d.seq))
          );
        }
        if (activePhase) {
          filteredDocs = filteredDocs.filter((d) => d.phase === activePhase);
        }
        document.querySelectorAll(".filter").forEach((input) => {
          const field = input.dataset.field;
          const value = input.value.trim().toLowerCase();
          if (value) {
            filteredDocs = filteredDocs.filter((d) =>
              String(d[field] || "")
                .toLowerCase()
                .includes(value)
            );
          }
        });

        if (filteredDocs.length === 0) {
          showToast("No data to print ‚ùó", "error");
          return;
        }

        // üîπ Sort by Seq
        filteredDocs.sort((a, b) => {
          const seqA = String(a.seq ?? "");
          const seqB = String(b.seq ?? "");
          const numA = Number(seqA);
          const numB = Number(seqB);
          if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
          return seqA.localeCompare(seqB);
        });

        // üîπ Group by Seq
        const grouped = {};
        filteredDocs.forEach((d) => {
          const seq = d.seq ?? "Unknown";
          if (!grouped[seq]) grouped[seq] = [];
          grouped[seq].push(d);
        });

        // üîπ Build rows
        const rows = Object.entries(grouped)
          .map(([seq, tasks]) => {
            tasks.sort((a, b) => {
              const cardA = a.task_card ?? "";
              const cardB = b.task_card ?? "";
              return String(cardA).localeCompare(String(cardB), undefined, {
                numeric: true,
                sensitivity: "base",
              });
            });

            const taskRows = tasks
              .map((d, index) => {
                const status = (d.status ?? "").toLowerCase();
                let bgColor = "background-color: #ffebee;"; // Light red
                let displayStatus = d.status ?? "";

                if (status === "closed") {
                  bgColor = "background-color: #e8f5e9;"; // Light green
                  displayStatus = "Closed";
                } else if (status === "cancel") {
                  bgColor = "background-color: #e8f5e9;"; // Light green
                  displayStatus = "Cancelled";
                } else if (status === "open") {
                  bgColor = "background-color: #ffebee;"; // Light red
                  displayStatus = "Open";
                }

                return `
            <tr class="${d.faded ? "faded" : ""}">
              ${
                index === 0
                  ? `<td rowspan="${tasks.length}">${
                      d.reference_task_card ?? ""
                    }</td>`
                  : ""
              }
              ${
                index === 0
                  ? `<td rowspan="${tasks.length}">${
                      d.task_card_description ?? ""
                    }</td>`
                  : ""
              }
              ${index === 0 ? `<td rowspan="${tasks.length}">${seq}</td>` : ""}
              <td class="taskcard-cell" style="${
                d.highlightTask ? "background-color: #f1f3f5;" : ""
              }">
                ${d.task_card ?? ""}
              </td>
              <td>${d.comment ?? ""}</td>
              <td>${d.status ?? ""}</td>
              <td style="${d.phase === "PH" ? bgColor : ""}">${
                  d.phase === "PH" ? d.skill : ""
                }</td>
              <td style="${d.phase === "P1" ? bgColor : ""}">${
                  d.phase === "P1" ? d.skill : ""
                }</td>
              <td style="${d.phase === "P2" ? bgColor : ""}">${
                  d.phase === "P2" ? d.skill : ""
                }</td>
              <td style="${d.phase === "P3" ? bgColor : ""}">${
                  d.phase === "P3" ? d.skill : ""
                }</td>
              <td style="${d.phase === "P4" ? bgColor : ""}">${
                  d.phase === "P4" ? d.skill : ""
                }</td>
              <td style="${d.phase === "P6" ? bgColor : ""}">${
                  d.phase === "P6" ? d.skill : ""
                }</td>
              <td style="${d.phase === "P0" ? bgColor : ""}">${
                  d.phase === "P0" ? d.skill : ""
                }</td>
            </tr>
          `;
              })
              .join("");

            return `
      <tbody class="seq-group">
        ${taskRows}
      </tbody>
    `;
          })
          .join("");

        // üîπ Get dynamic header content and add selected skill
        const dynamicHeader =
          document.getElementById("dynamicHeader")?.textContent || "";

        let selectedSkillText = "";
        if (activeSkill && activeSkill !== "CLEAR") {
          selectedSkillText = ` - Selected Skill: <b>${activeSkill}</b>`;
        }

        // Build header additions
        let headerFilters = "";

        // Skill filter
        if (activeSkill && activeSkill !== "CLEAR") {
          headerFilters += ` | Skill: ${activeSkill}`;
        }

        // Multi / Single Skill
        if (multiSkillActive) headerFilters += " | Multi-Skill MTC";
        if (singleSkillActive) headerFilters += " | Single-Skill MTC";

        // Phase filter
        if (activePhase) headerFilters += ` | Phase: ${activePhase}`;

        // Seq filter(s)
        if (seqFilterValues && seqFilterValues.length > 0) {
          headerFilters += ` | Seq: ${seqFilterValues.join(", ")}`;
        }

        // Text filters
        document.querySelectorAll(".filter").forEach((input) => {
          const field = input.dataset.field;
          const value = input.value.trim();
          if (value) {
            headerFilters += ` | ${field}: "${value}"`;
          }
        });

        // Final header
        const fullHeader = `${dynamicHeader}${headerFilters}`;

        const tableHTML = `
      <table>
        <thead>
          <tr>
            <th colspan="13" style="text-align:center; font-size:14px; font-weight:bold; background:white; border-bottom: 2px solid #000;">
              ${fullHeader}
            </th>
          </tr>
          <tr>
            <th>Reference</th>
            <th>Description</th>
            <th>Seq.No</th>
            <th>TaskCard Items</th>
            <th>Comments</th>
            <th>Status</th>
            <th>PH</th>
            <th>P1</th>
            <th>P2</th>
            <th>P3</th>
            <th>P4</th>
            <th>P6</th>
            <th>P0</th>
          </tr>
        </thead>
        ${rows}
      </table>
    `;

        // üîπ Open print window
        const printWindow = window.open("", "_blank");
        printWindow.document.write(`
      <html>
        <head>
          <title>Print Table</title>
          <style>
            @page { 
              size: landscape;
              margin: 15mm;
              @bottom-right {
                content: "Page " counter(page) " of " counter(pages);
                font-size: 10px;
                color: #555;
                font-family: Arial, sans-serif;
              }
            }
            body { 
              font-family: Arial, sans-serif; 
              margin: 0;
              padding: 0;
              font-size: 10px; 
              counter-reset: page;
            }
            table { 
              border-collapse: collapse; 
              width: 100%;
              font-size: 10px;
            } 
            th, td { 
              border: 1px solid #000; 
              padding: 4px; 
              text-align: center; 
              vertical-align: middle;
              word-wrap: break-word;
            }
            td.taskcard-cell {
              white-space: nowrap; 
              text-overflow: ellipsis; 
              overflow: hidden; 
              max-width: 300px;
            }
            th { background: #f2f2f2; }
            thead {
              display: table-header-group;
            }
            .seq-group {
              page-break-inside: avoid;
            }
            tbody.seq-group:not(:first-of-type) tr:first-child td {
              border-top: 2px solid #000;
            }
          </style>
        </head>
        <body>
          ${tableHTML}
        </body>
      </html>
    `);
        printWindow.document.close();
      }

      window.printFullTable = printFullTable;

      let prevDocsMap = new Map(); // üß† Cache to detect changes
      let commentFlashDuration = 1000; // highlight for 1 second
      // üß† Badge Notification Logic
      const badgeElements = document.querySelectorAll(".comment-badge");
      let badgeCounts = JSON.parse(localStorage.getItem("badgeCounts")) || {};
      let lastCommentMap = new Map();
      let initialLoadDone = false;

      function updateBadgeDisplay() {
        document.querySelectorAll(".comment-badge").forEach((badge) => {
          const skill = badge.dataset.skill;
          const count = badgeCounts[skill] || 0;
          if (count > 0) {
            badge.textContent = count;
            badge.style.display = "inline-block";
          } else {
            badge.style.display = "none";
          }
        });

        // üîπ Save to localStorage
        localStorage.setItem("badgeCounts", JSON.stringify(badgeCounts));
      }
      // === COMMENT POPUP WHEN BADGE CLICKED ===
      let commentPopup = document.getElementById("commentListPopup");

      if (!commentPopup) {
        commentPopup = document.createElement("div");
        commentPopup.id = "commentListPopup";
        commentPopup.style.cssText = `
      display: none;
      position: fixed;
      inset: 0;
      backdrop-filter: blur(3px);
      background: rgba(0, 0, 0, 0.55);
      justify-content: flex-end;
      align-items: center;
      z-index: 99999;
    `;

        commentPopup.innerHTML = `
      <div class="popup-card" style="
        background: rgba(255,255,255,0.9);
        border: 1px solid rgba(255,255,255,0.5);
        border-radius: 18px 0 0 18px;
        padding: 24px;
        width: 420px;
        max-height: 90vh;
        overflow-y: auto;
        box-shadow: -6px 0 30px rgba(0,0,0,0.25);
        font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'SF Pro Display', Roboto, sans-serif;
        animation: slideInRight 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
      ">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:18px;">
          <h3 id="popupTitle" style="margin:0; font-size:20px; font-weight:600; color:var(--lufthansa-blue);">Comments</h3>
          <button id="popupClose" style="
            background:none;
            border:none;
            font-size:24px;
            color:#666;
            cursor:pointer;
            transition:0.25s;
          ">&times;</button>
        </div>
        <div id="popupComments" style="font-size:14px; color:#222; line-height:1.6; border-top:1px solid rgba(0,0,0,0.05); padding-top:10px;">
        </div>
      </div>
    `;
        document.body.appendChild(commentPopup);

        const style = document.createElement("style");
        style.textContent = `
      @keyframes slideInRight {
        from { transform: translateX(100%); opacity: 0; }
        to { transform: translateX(0); opacity: 1; }
      }
      @keyframes slideOutRight {
        from { transform: translateX(0); opacity: 1; }
        to { transform: translateX(100%); opacity: 0; }
      }
      #popupClose:hover {
        color:#000;
        transform: scale(1.1);
      }
    `;
        document.head.appendChild(style);
      }

      // === Popup Open / Close Functions ===
      function openPopup(title, htmlContent) {
        const popupCard = commentPopup.querySelector(".popup-card");
        const titleEl = commentPopup.querySelector("#popupTitle");
        const commentsEl = commentPopup.querySelector("#popupComments");

        titleEl.textContent = title;
        commentsEl.innerHTML = htmlContent || "No comments yet.";

        commentPopup.style.display = "flex";
        popupCard.style.animation = "slideInRight 0.4s ease";
      }

      function closePopup() {
        const popupCard = commentPopup.querySelector(".popup-card");
        popupCard.style.animation = "slideOutRight 0.3s ease forwards";
        setTimeout(() => {
          commentPopup.style.display = "none";
        }, 280);
        badgeCounts[activeSkill] = 0;
        updateBadgeDisplay();
      }

      // Close button
      commentPopup.querySelector("#popupClose").onclick = closePopup;

      // Close when clicking outside the card
      commentPopup.addEventListener("click", (e) => {
        if (e.target === commentPopup) closePopup();
      });

      // ‚úÖ 4Ô∏è‚É£ Helper: format comment block
      function formatComment(comment) {
        const lines = comment.split("\n").reverse(); // latest first
        return lines
          .map((line) => {
            line = line.trim();
            // Ensure every line starts with üïí or [
            return line.startsWith("üïí") || line.startsWith("[")
              ? line
              : `[No Date] ${line}`;
          })
          .join("\n");
      }

      // ‚úÖ Main listener
      document.addEventListener("click", (e) => {
        const badge = e.target.closest(".comment-badge");
        if (!badge) return;

        e.stopPropagation();
        e.preventDefault();

        const skill = badge.dataset.skill;

        // Filter docs by skill or CLEAR (all)
        const skillDocs = getSkillFilteredDocs().filter((d) => {
          if (skill === "CLEAR") return true;
          if (skillGroups[skill]) return skillGroups[skill].includes(d.skill);
          return d.skill === skill;
        });

        // Gather and sort comments
        const commentEntries = skillDocs
          .map((d) => ({
            seq: d.seq ?? "",
            task_card: d.task_card ?? "",
            comment: d.comment ?? "",
          }))
          .filter((x) => x.comment.trim() !== "")
          .sort(
            (a, b) =>
              extractLastTimestamp(b.comment) - extractLastTimestamp(a.comment)
          );

        // Build popup HTML
        const htmlContent =
          commentEntries.length === 0
            ? "No comments yet."
            : commentEntries
                .map(
                  (c) => `
    <div style="margin-bottom: 12px; border-bottom: 1px solid #eee; padding-bottom: 8px;">
      <strong style="color: #333;">üîπ Seq ${c.seq}</strong> ‚Äî ${c.task_card}
      <div style="margin:3px 0 5px 10px; padding-left:5px; border-left:2px solid var(--lufthansa-blue); white-space:pre-line; font-size: 13px; color: #444;">
        ${formatComment(c.comment)}
      </div>
    </div>
    `
                )
                .join("");

        openPopup(
          `Comments ‚Äì ${skill === "CLEAR" ? "ALL" : skill}`,
          htmlContent
        );
      });

      // 3Ô∏è‚É£ Helper: extract timestamp
      function extractLastTimestamp(commentText) {
        const matches = [...commentText.matchAll(/\[(.*?)\]/g)];
        if (matches.length === 0) return 0;
        const last = matches[matches.length - 1][1];
        const parsed = Date.parse(last);
        return isNaN(parsed) ? 0 : parsed;
      }

      // üëá Called inside your onSnapshot listener
      function mapToGroupSkill(rawSkill) {
        // match Firestore skill to button skill
        for (const [group, members] of Object.entries(skillGroups)) {
          if (members.includes(rawSkill)) return group;
        }
        return rawSkill; // fallback if not found
      }

      function handleCommentBadgeUpdates(snapshot) {
        const newMap = new Map();
        snapshot.docs.forEach((d) => newMap.set(d.id, d.data()));

        if (initialLoadDone) {
          // Only increment badges if it's not the first load
          snapshot.docs.forEach((docSnap) => {
            const data = docSnap.data();
            const rawSkill = data.skill || "CLEAR";
            const skill = mapToGroupSkill(rawSkill);

            const prev = lastCommentMap.get(docSnap.id);
            const oldComment = prev?.comment || "";
            const newComment = data.comment || "";

            if (newComment !== oldComment) {
              badgeCounts[skill] = (badgeCounts[skill] || 0) + 1;
            }
          });
          updateBadgeDisplay();
        }

        // Update map after processing
        lastCommentMap = newMap;

        // Mark first snapshot as done
        if (!initialLoadDone) initialLoadDone = true;
      }

      async function renderRows(docs) {
        // ‚úÖ Precompute selected skills ONCE
        let selectedSkills = [];
        if (activeSkill !== "CLEAR") {
          selectedSkills = skillGroups[activeSkill]
            ? skillGroups[activeSkill]
            : [activeSkill];
        }

        // üîç Build map for detecting changes
        const newDocsMap = new Map(docs.map((d) => [d.id, d]));

        // ‚úÖ Detect if only comments changed (avoid full rebuild)
        if (prevDocsMap.size > 0 && newDocsMap.size === prevDocsMap.size) {
          const changed = [];
          for (const [id, newDoc] of newDocsMap.entries()) {
            const oldDoc = prevDocsMap.get(id);
            if (!oldDoc) continue;
            // Only check for comment field differences
            if (oldDoc.comment !== newDoc.comment) {
              changed.push({ id, comment: newDoc.comment });
            }
          }

          // üß© If exactly 1 or few comment changes ‚Äî update inline
          if (changed.length > 0 && changed.length <= 5) {
            changed.forEach(({ id, comment }) => {
              const ta = document.querySelector(
                `.comment-input[data-id="${id}"]`
              );
              if (ta) {
                // Update text and resize
                ta.value = comment || "";
                ta.style.height = "auto";
                ta.style.height = ta.scrollHeight + "px";

                // Highlight briefly to show real-time change
                ta.classList.add("comment-updated");
                setTimeout(
                  () => ta.classList.remove("comment-updated"),
                  commentFlashDuration
                );
              }
            });

            prevDocsMap = newDocsMap;
            return; // Skip full rebuild
          }
        }

        // üß† Save latest docs map
        prevDocsMap = newDocsMap;

        // üîπ Group by seq
        const grouped = {};
        docs.forEach((d) => {
          const seq = d.seq ?? "Unknown";
          if (!grouped[seq]) grouped[seq] = [];
          grouped[seq].push(d);
        });

        // üîπ Sort groups by seq
        const sortedGroups = Object.entries(grouped).sort(([seqA], [seqB]) => {
          const numA = Number(seqA);
          const numB = Number(seqB);
          if (!isNaN(numA) && !isNaN(numB)) return numA - numB;
          return String(seqA).localeCompare(String(seqB));
        });

        // üîπ Build all rows
        const rows = sortedGroups.flatMap(([seq, tasks]) => {
          tasks.sort((a, b) =>
            String(a.task_card ?? "").localeCompare(
              String(b.task_card ?? ""),
              undefined,
              { numeric: true }
            )
          );

          const hasCancelled = tasks.some(
            (t) => (t.status ?? "").toLowerCase() === "cancel"
          );
          const allClosed = tasks.every(
            (t) => (t.status ?? "").toLowerCase() === "closed"
          );

          let finalStatus = "Open";
          let statusColor = "var(--lufthansa-danger)";
          if (hasCancelled) {
            finalStatus = "Cancelled";
            statusColor = "var(--lufthansa-success)";
          } else if (allClosed) {
            finalStatus = "Closed";
            statusColor = "var(--lufthansa-success)";
          }

          return tasks.map((t, index) => {
            const hasSelectedSkill = tasks.some(
              (x) =>
                selectedSkills.length > 0 && selectedSkills.includes(x.skill)
            );
            const rowHasSelectedSkill = tasks.some(
              (x) =>
                x.task_card === t.task_card && selectedSkills.includes(x.skill)
            );

            let baseCellStyle = "";
            if (
              selectedSkills.length > 0 &&
              hasSelectedSkill &&
              !rowHasSelectedSkill
            ) {
              baseCellStyle =
                " color:#adb5bd; border-radius:3px; padding:2px 4px;"; // Faded color
            }

            const phaseCells = fixedPhases
              .map((phase) => {
                const skills = tasks
                  .filter(
                    (x) => x.phase === phase && x.task_card === t.task_card
                  )
                  .map((x) => {
                    const status = (x.status ?? "").toLowerCase();
                    let color =
                      status === "closed" || status === "cancel"
                        ? "var(--lufthansa-success)"
                        : "var(--lufthansa-danger)";
                    let highlightStyle = "";

                    if (
                      selectedSkills.length > 0 &&
                      selectedSkills.includes(x.skill)
                    ) {
                      highlightStyle = "font-weight: bold;";
                    } else if (hasSelectedSkill && !rowHasSelectedSkill) {
                      highlightStyle =
                        "opacity: 0.5; border-radius:3px; padding:1px 3px;";
                    }

                    return `<div style="color:${color}; ${highlightStyle}">
                      ${x.skill ?? ""}
                    </div>`;
                  })
                  .join("<br>");

                return `<td class="phase-cell">${skills || ""}</td>`;
              })
              .join("");

            return `
      <tr id="row-seq-${seq}">
        ${
          index === 0
            ? `<td rowspan="${tasks.length}">${
                t.reference_task_card ?? ""
              }</td>`
            : ""
        }
        ${
          index === 0
            ? `<td rowspan="${tasks.length}">${
                t.task_card_description ?? ""
              }</td>`
            : ""
        }
        ${
          index === 0
            ? `<td rowspan="${tasks.length}" style="text-align:center; vertical-align:middle;">
                  <a href="https://ltpsystems.sharepoint.com/sites/BaseMaintenance/Shared%20Documents/Forms/AllItems.aspx?viewid=59208620%2Dd7d3%2D4b91%2D8262%2D732edcfe6e96&id=%2Fsites%2FBaseMaintenance%2FShared%20Documents%2FONEMTC%2F${currentWO}%2F${seq}%2Epdf&parent=%2Fsites%2FBaseMaintenance%2FShared%20Documents%2FONEMTC%2F${currentWO}" 
                    target="_blank" 
                    style="color:var(--lufthansa-blue); text-decoration:underline; cursor:pointer; font-weight: 500;">
                    ${seq}
                  </a>
                </td>`
            : ""
        }
        ${
          index === 0
            ? `<td rowspan="${tasks.length}" style="text-align:center; vertical-align:middle; font-weight:bold; color:${statusColor};">
                  ${finalStatus}
                </td>`
            : ""
        }
        <td style="text-align:center; vertical-align:middle; ${baseCellStyle}">
          ${t.task_card ?? ""}
        </td>

        <td class="comment-cell">
          <textarea class="comment-input" data-id="${t.id}" rows="1">${
              t.comment || ""
            }</textarea>
        </td>

        ${phaseCells}
      </tr>`;
          });
        });

        // Preserve scroll
        const scrollContainer = document.querySelector("#scrollArea");
        const prevScrollTop = scrollContainer ? scrollContainer.scrollTop : 0;

        // ü™∂ Smooth no-flicker refresh
        if (scrollContainer) scrollContainer.style.visibility = "hidden";

        requestAnimationFrame(() => {
          clusterize.clear();
          clusterize.update(
            rows.length
              ? rows
              : [
                  `<tr class="clusterize-no-data"><td colspan="12">No data</td></tr>`,
                ]
          );

          if (scrollContainer) scrollContainer.scrollTop = prevScrollTop;
          if (scrollContainer) scrollContainer.style.visibility = "visible";
          // ü™Ñ Auto-resize all visible comments after render
          requestAnimationFrame(() => {
            document.querySelectorAll(".comment-input").forEach((ta) => {
              ta.style.height = "auto";
              ta.style.height = ta.scrollHeight + "px";
            });
          });
        });

        // ‚ú® Add CSS for highlight and popup only once
        if (!document.querySelector("#comment-style")) {
          const style = document.createElement("style");
          style.id = "comment-style";
          style.textContent = `
      .comment-popup { position: fixed; inset: 0; display: flex; justify-content: center; align-items: center; background: rgba(0,0,0,0.2); z-index: 9999; }
      .comment-popup input { width: 380px; padding: 10px 14px; border: 1px solid var(--lufthansa-border); border-radius: var(--lufthansa-radius); font-size: 15px; background: white; color: #333; box-shadow: 0 2px 8px rgba(0,0,0,0.1); outline: none; }
      .comment-popup input:focus { border-color: var(--lufthansa-blue); }
      .ta-highlight { outline: 2px solid var(--lufthansa-blue); background: #f0f6ff; }
      .comment-updated { transition: background 0.3s ease; background: #fff9db; } /* üí° yellow flash */
      `;
          document.head.appendChild(style);
        }

        // üß† Comment popup logic
        if (!scrollContainer.dataset.popupBound) {
          scrollContainer.dataset.popupBound = "true"; // ‚úÖ bind only once

          scrollContainer.addEventListener("focusin", (e) => {
            const ta = e.target.closest(".comment-input");
            if (!ta) return;

            ta.classList.add("ta-highlight");
            ta.readOnly = true;

            if (document.querySelector(".comment-popup")) return;

            const popup = document.createElement("div");
            popup.className = "comment-popup";
            const input = document.createElement("input");
            input.type = "text";
            input.placeholder = "Type your comment and press Enter...";
            popup.appendChild(input);
            document.body.appendChild(popup);
            setTimeout(() => input.focus(), 30);

            const closePopup = () => {
              popup.remove();
              ta.classList.remove("ta-highlight");
              ta.readOnly = false;
            };

            input.addEventListener("keydown", async (e2) => {
              if (e2.key === "Enter" && input.value.trim()) {
                e2.preventDefault();
                const docId = ta.dataset.id;
                const rawComment = input.value.trim();
                let modifiedBy = loginUser || "Unknown"; // Use global var

                const now = new Date();
                const timestamp = now.toLocaleString("en-US", {
                  month: "short",
                  day: "2-digit",
                  hour: "2-digit",
                  minute: "2-digit",
                  hour12: false,
                });

                try {
                  const docRef = doc(db, "tasks", docId);
                  const snap = await getDoc(docRef);
                  const existingComment = snap.exists()
                    ? snap.data().comment || ""
                    : "";

                  const newEntry = `[${timestamp}] ${modifiedBy}: ${rawComment}`;
                  const combinedComment = existingComment
                    ? existingComment + "\n" + newEntry
                    : newEntry;

                  await updateDoc(docRef, { comment: combinedComment });
                  ta.value = combinedComment;
                  ta.style.height = "auto";
                  ta.style.height = ta.scrollHeight + "px";
                  closePopup();
                } catch (err) {
                  console.error("‚ùå Error saving comment:", err);
                  showToast("Failed to save comment", "error");
                  closePopup();
                }
              } else if (e2.key === "Escape") {
                closePopup();
              }
            });

            popup.addEventListener("click", (e3) => {
              if (e3.target === popup) closePopup();
            });
          });

          // Optional: autoresize all comment textareas on input
          scrollContainer.addEventListener("input", (e) => {
            const ta = e.target.closest(".comment-input");
            if (ta) {
              ta.style.height = "auto";
              ta.style.height = ta.scrollHeight + "px";
            }
          });
        }
      }

      function renderPhaseTotals(docs) {
        // Counters
        const phaseTotals = {};
        const phaseOpen = {};
        const phaseClosed = {};
        const phaseCancelled = {};
        const phaseHold = {};

        // Count tasks by phase
        docs.forEach((d) => {
          const phase = d.phase || "No Phase";
          if (!fixedPhases.includes(phase)) return; // ignore unknown phases
          phaseTotals[phase] = (phaseTotals[phase] || 0) + 1;
          const st = (d.status || "").toLowerCase();
          if (st === "open") phaseOpen[phase] = (phaseOpen[phase] || 0) + 1;
          if (st === "closed" || st === "completed")
            phaseClosed[phase] = (phaseClosed[phase] || 0) + 1;
          if (st === "cancel")
            phaseCancelled[phase] = (phaseCancelled[phase] || 0) + 1;
          if (st === "hold") phaseHold[phase] = (phaseHold[phase] || 0) + 1;
        });

        // Render table body (always fixed phases)
        const body = document.getElementById("phaseTotalsBody");
        body.innerHTML = "";

        fixedPhases.forEach((phase) => {
          const total = phaseTotals[phase] || 0;

          if (total === 0) {
            body.insertAdjacentHTML(
              "beforeend",
              `<tr>
            <td class="phase-cell" data-phase="${phase}" style="cursor:not-allowed; color:#adb5bd;">
              ${phase}
            </td>
            <td style="text-align:right; background:#f8f9fa; color:#adb5bd;">-</td>
            <td style="text-align:right; background:#f8f9fa; color:#adb5bd;">-</td>
            <td style="text-align:right; background:#f8f9fa; color:#adb5bd;">-</td>
            <td style="text-align:right; background:#f8f9fa; color:#adb5bd;">-</td>
            <td style="text-align:right; background:#f8f9fa; color:#adb5bd;">-</td>
          </tr>`
            );
          } else {
            const open = phaseOpen[phase] || 0;
            const closed = phaseClosed[phase] || 0;
            const cancelledCount = phaseCancelled[phase] || 0;
            const hold = phaseHold[phase] || 0;
            const pct = (((closed + cancelledCount) / total) * 100).toFixed(1);

            body.insertAdjacentHTML(
              "beforeend",
              `<tr>
            <td class="phase-cell" data-phase="${phase}" style="cursor:pointer; color:var(--lufthansa-blue); text-decoration:underline; font-weight: 500;">
              ${phase}
            </td>
            <td style="text-align:right;">${open}</td>
            <td style="text-align:right;">${closed}</td>
            <td style="text-align:right;">${cancelledCount}</td>
            <td style="text-align:right;">${hold}</td>
            <td style="text-align:right;">${pct}%</td>
          </tr>`
            );
          }
        });

        // ---- Create Chart Data ----
        const phaseLabels = [];
        const closedPercentages = [];

        fixedPhases.forEach((phase) => {
          const total = phaseTotals[phase] || 0;
          const closed = phaseClosed[phase] || 0;
          const cancelled = phaseCancelled[phase] || 0;
          const pct = total
            ? (((closed + cancelled) / total) * 100).toFixed(1)
            : 0;
          phaseLabels.push(phase);
          closedPercentages.push(pct);
        });
        // ‚úÖ Insert total row here
        const totalOpen = Object.values(phaseOpen).reduce((a, b) => a + b, 0);
        const totalClosed = Object.values(phaseClosed).reduce(
          (a, b) => a + b,
          0
        );
        const totalCancelled = Object.values(phaseCancelled).reduce(
          (a, b) => a + b,
          0
        );
        const totalHold = Object.values(phaseHold).reduce((a, b) => a + b, 0);
        const grandTotal = totalOpen + totalClosed + totalCancelled + totalHold;
        const totalPct = grandTotal
          ? (((totalClosed + totalCancelled) / grandTotal) * 100).toFixed(1)
          : 0;

        body.insertAdjacentHTML(
          "beforeend",
          `<tr style="font-weight:bold; background:#e7f5ff;">
        <td style="text-align:left;">TOTAL</td>
        <td style="text-align:right;">${totalOpen}</td>
        <td style="text-align:right;">${totalClosed}</td>
        <td style="text-align:right;">${totalCancelled}</td>
        <td style="text-align:right;">${totalHold}</td>
        <td style="text-align:right;">${totalPct}%</td>
      </tr>`
        );
        // ---- Render or Update Chart ----
        if (window.phaseChartInstance) {
          window.phaseChartInstance.data.labels = phaseLabels;
          window.phaseChartInstance.data.datasets[0].data = closedPercentages;
          window.phaseChartInstance.update();
        } else {
          const ctx = document.getElementById("phaseChart").getContext("2d");
          window.phaseChartInstance = new Chart(ctx, {
            type: "bar",
            data: {
              labels: phaseLabels,
              datasets: [
                {
                  label: "% Closed",
                  data: closedPercentages,
                  backgroundColor: "rgba(5, 22, 77, 0.7)", // Lufthansa Blue
                  borderColor: "rgba(5, 22, 77, 1)",
                  borderWidth: 1,
                  borderRadius: 4,
                },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              plugins: {
                legend: { display: false },
                tooltip: {
                  callbacks: {
                    label: (ctx) => `${ctx.parsed.y}% closed`,
                  },
                },
              },
              scales: {
                y: {
                  beginAtZero: true,
                  max: 100,
                  title: { display: true, text: "% Closed" },
                },
                x: {
                  title: { display: true, text: "Phase" },
                },
              },
            },
          });
        }

        // Attach click listeners
        document
          .querySelectorAll("#phaseTotalsBody .phase-cell")
          .forEach((cell) => {
            cell.addEventListener("click", () => {
              const phase = cell.dataset.phase;

              // Toggle filter
              if (activePhase === phase) {
                activePhase = null;
              } else {
                activePhase = phase;
              }

              applyFilters();
            });
          });
      }

      const skillGroups = {
        CLEAR: [],
        AVI: ["AVI"],
        "CRG/ENG": ["CRG", "ENG-E", "ENG-F"],
        CAB: ["CAB"],
        "LDG/FLC": ["LDG", "FLC-W", "FLC-T"],
        STR: ["STR"],
        GEN: ["GEN"],
      };
      // ====== DYNAMIC BUTTON POPULATION ======
      function populateDynamicSkillButtons() {
        const container = document.querySelector(".skill-filters");

        const predefined = new Set(Object.values(skillGroups).flat());
        const allSkills = new Set(allDocs.map((d) => d.skill).filter(Boolean));
        const dynamicSkills = [...allSkills].filter((s) => !predefined.has(s));

        // Remove old dynamic buttons
        container
          .querySelectorAll("button[data-dynamic='true']")
          .forEach((btn) => btn.remove());

        // Add new dynamic buttons
        dynamicSkills.forEach((skill) => {
          const btn = document.createElement("button");
          btn.textContent = skill;
          btn.dataset.skill = skill;
          btn.dataset.dynamic = "true";
          container.appendChild(btn);

          // ‚úÖ Create badge span for the button
          const badge = document.createElement("span");
          badge.className = "comment-badge";
          badge.dataset.skill = skill;
          badge.style.display = "none"; // hidden initially
          btn.appendChild(badge);
        });

        // Re-attach listeners
        attachSkillButtonListeners();

        // Update badges immediately
        updateBadgeDisplay();
      }

      function attachSkillButtonListeners() {
        document.querySelectorAll(".skill-filters button").forEach((btn) => {
          // Remove old listener to prevent duplicates
          btn.onclick = null;
          // Add new one
          btn.onclick = () => {
            document
              .querySelectorAll(".skill-filters button")
              .forEach((b) => b.classList.remove("active"));
            btn.classList.add("active");

            activeSkill = btn.dataset.skill;
            localStorage.setItem("activeSkill", activeSkill);

            if (activeSkill === "CLEAR") {
              scannedSeqs = [];
              seqFilterValues = [];
              document
                .querySelectorAll(".filter")
                .forEach((input) => (input.value = ""));
            }

            applyFilters();
          };
        });
      }

      document.getElementById("multiSkillBtn").addEventListener("click", () => {
        multiSkillActive = !multiSkillActive;
        singleSkillActive = false; // ensure mutual exclusivity

        const multiBtn = document.getElementById("multiSkillBtn");
        const singleBtn = document.getElementById("singleSkillBtn");

        multiBtn.classList.toggle("active", multiSkillActive);
        singleBtn.classList.remove("active");

        applyFilters();
      });
      document
        .getElementById("singleSkillBtn")
        .addEventListener("click", () => {
          singleSkillActive = !singleSkillActive;
          multiSkillActive = false; // ensure mutual exclusivity

          const multiBtn = document.getElementById("multiSkillBtn");
          const singleBtn = document.getElementById("singleSkillBtn");

          singleBtn.classList.toggle("active", singleSkillActive);
          multiBtn.classList.remove("active");

          applyFilters();
        });
      function getSkillFilteredDocs() {
        if (activeSkill === "CLEAR") return allDocs;

        if (skillGroups[activeSkill]) {
          // Predefined group
          const skills = skillGroups[activeSkill];
          return allDocs.filter((d) => skills.includes(d.skill));
        }

        // Dynamic skill
        return allDocs.filter((d) => d.skill === activeSkill);
      }

      async function applyFilters() {
        // 1. Get all active filter values ONCE
        const filters = {};
        document.querySelectorAll(".filter").forEach((input) => {
          const v = input.value.trim().toLowerCase();
          if (v && input.dataset.field !== "seq") {
            filters[input.dataset.field] = v;
          }
        });

        // 2. Start with docs that match the active skill
        let skillFilteredDocs = getSkillFilteredDocs();
        const skillBaseTotal = skillFilteredDocs.length;

        // 3. Build a map of seq -> skill count
        const seqSkillMap = {};
        if (multiSkillActive || singleSkillActive) {
          allDocs.forEach((d) => {
            const seq = String(d.seq);
            if (!seqSkillMap[seq]) seqSkillMap[seq] = new Set();
            if (d.skill) seqSkillMap[seq].add(d.skill);
          });
        }

        // 4. Find all SEQs that match ALL criteria
        const matchingSeqs = new Set();
        for (const d of skillFilteredDocs) {
          const seqStr = String(d.seq);

          // Check text filters
          if (
            !Object.keys(filters).every((field) =>
              String(d[field] ?? "")
                .toLowerCase()
                .includes(filters[field])
            )
          ) {
            continue;
          }

          // Check seq text filter
          if (seqFilterValues.length > 0 && !seqFilterValues.includes(seqStr)) {
            continue;
          }

          // Check scanned seq filter
          if (scannedSeqs.length > 0 && !scannedSeqs.includes(Number(d.seq))) {
            continue;
          }

          // Check phase filter
          if (activePhase && d.phase !== activePhase) {
            continue;
          }

          // Check multi/single skill filters
          if (multiSkillActive && (seqSkillMap[seqStr]?.size || 0) <= 1) {
            continue;
          }
          if (singleSkillActive && (seqSkillMap[seqStr]?.size || 0) !== 1) {
            continue;
          }

          matchingSeqs.add(seqStr);
        }

        // 5. Now, get all docs that belong to those matching SEQs
        const rowsToRender = allDocs.filter((d) =>
          matchingSeqs.has(String(d.seq))
        );
        // 5b. üîΩ NEW: Get docs for counters (only tasks matching skill *and* seq filters)
        const finalFilteredDocs = skillFilteredDocs.filter((d) =>
          matchingSeqs.has(String(d.seq))
        );
        // 6. Render the final list
        renderRows(rowsToRender);

        // 7. Update counters
        updateCounters(finalFilteredDocs, skillBaseTotal); // üëà ‚úÖ FIXED

        // 8. Update JC Chart
        if (
          typeof renderJCChart === "function" &&
          typeof currentWO !== "undefined"
        ) {
          await renderJCChart(currentWO, skillFilteredDocs);
        }
      }

      function updateCounters(skillFilteredDocs, skillBaseTotal) {
        const pctClosed = getClosedPercentage(skillFilteredDocs);

        // --- MTC Counts ---
        const seqGroups = {};
        skillFilteredDocs.forEach((d) => {
          const seq = String(d.seq);
          if (!seqGroups[seq]) seqGroups[seq] = [];
          seqGroups[seq].push(d.status?.toLowerCase());
        });

        let totalMTC = 0,
          closedMTC = 0,
          openMTC = 0;
        Object.keys(seqGroups).forEach((seq) => {
          totalMTC++;
          const allClosed = seqGroups[seq].every(
            (s) => s === "closed" || s === "cancel" || s === "completed"
          );
          if (allClosed) closedMTC++;
          else openMTC++;
        });
        // --- End MTC Counts ---

        let counterText = `Showing ${skillFilteredDocs.length} of ${skillBaseTotal} tasks ‚Ä¢ 
    <span class="highlight">${pctClosed}% Closed</span>
    &nbsp;&nbsp;&nbsp; 
    Total MTC ${totalMTC} ‚Ä¢ 
    <span style="color:var(--lufthansa-danger); font-weight:bold;">Open MTC ${openMTC}</span> ‚Ä¢ 
    <span style="color:var(--lufthansa-success); font-weight:bold;">Closed MTC ${closedMTC}</span>`;

        if (activePhase) {
          counterText += ` ‚Ä¢ Filter: <span class="highlight">${activePhase}</span>
      <button id="clearPhaseBtn" style="margin-left:8px; padding:2px 8px; font-size:11px; background:#eee; border:1px solid #ccc; border-radius:12px; cursor:pointer; color:#333;">
        Clear
      </button>`;
        }

        if (activeSkill && activeSkill !== "CLEAR") {
          counterText += ` ‚Ä¢ Skill: <span class="highlight">${activeSkill}</span>`;
        }

        counterEl.innerHTML = counterText;

        // Re-attach listener for the clear button
        document
          .getElementById("clearPhaseBtn")
          ?.addEventListener("click", () => {
            activePhase = null;
            applyFilters();
          });

        // Seq clear button
        const clearSeqBtn = document.getElementById("clearSeqBtn");
        clearSeqBtn.style.display =
          seqFilterValues.length > 0 || scannedSeqs.length > 0
            ? "inline"
            : "none";
        clearSeqBtn.onclick = () => {
          scannedSeqs = [];
          seqFilterValues = [];
          const seqInput = document.querySelector('.filter[data-field="seq"]');
          if (seqInput) seqInput.value = "";
          applyFilters();
        };

        renderPhaseTotals(skillFilteredDocs);
      }

      const seqInput = document.querySelector('.filter[data-field="seq"]');
      seqInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          const val = seqInput.value.trim();
          if (val !== "" && !seqFilterValues.includes(val)) {
            seqFilterValues.push(val);
          }
          seqInput.value = "";
          applyFilters();
        }
      });

      attachSkillButtonListeners();

      document
        .querySelectorAll(".filter")
        .forEach((input) =>
          input.addEventListener("input", debouncedApplyFilters)
        );

      /* =======================
        Firestore Query by WO
      ======================== */
      function searchWorkorder(wo) {
        if (!wo) return;
        showLoading();
        counterEl.textContent = "Loading tasks...";
        localStorage.setItem("lastWorkorder", wo);
        if (unsubscribe) {
          unsubscribe();
          unsubscribe = null;
        }

        currentWO = isNaN(wo) ? wo : Number(wo);
        activeWOEl.textContent = String(currentWO);

        const qWO = query(
          collection(db, "tasks"),
          where("wo", "==", currentWO)
        );
        unsubscribe = onSnapshot(
          qWO,
          (snapshot) => {
            handleCommentBadgeUpdates(snapshot);
            allDocs = snapshot.docs.map((docSnap) => ({
              id: docSnap.id,
              ...docSnap.data(),
            }));

            const pctClosed = getClosedPercentage(allDocs);
            counterEl.innerHTML = `Total Tasks: ${snapshot.size} ‚Ä¢ <span class="highlight">${pctClosed}% Closed</span>`;

            //################## Dynamic header
            if (allDocs.length > 0) {
              const ac = allDocs[0].ac || "Unknown AC";
              const schedStart = allDocs[0].sched_start_date;
              const schedEnd = allDocs[0].sched_end_date;

              const dayProgress = calculateDayProgress(
                schedStart,
                schedEnd,
                allDocs[0].wo,
                currentWO
              );

              document.getElementById(
                "dynamicHeader"
              ).textContent = `MTC Status for ${ac} ${dayProgress || ""}`;
            }

            lastUpdateEl.textContent = "Live ‚Ä¢ " + new Date().toLocaleString();
            //################## Dynamic header

            if (
              activeSkill !== "CLEAR" ||
              activePhase ||
              scannedSeqs.length > 0 ||
              seqFilterValues.length > 0 ||
              multiSkillActive ||
              singleSkillActive
            ) {
              applyFilters();
            } else {
              renderRows(allDocs);
              renderPhaseTotals(allDocs);
              renderJCChart(wo, allDocs);
            }

            // üîπ Preserve skill button highlight
            document
              .querySelectorAll(".skill-filters button")
              .forEach((b) => b.classList.remove("active"));
            const activeBtn = document.querySelector(
              `.skill-filters button[data-skill="${activeSkill}"]`
            );
            if (activeBtn) activeBtn.classList.add("active");

            // üîπ Regenerate dynamic skill buttons
            populateDynamicSkillButtons();

            hideLoading();
          },
          (err) => {
            console.error(err);
            hideLoading();
            showToast("Error loading tasks.", "error");
          }
        );
      }

      woSearchBtn.addEventListener("click", () => {
        const wo = woInput.value.trim();
        if (wo) searchWorkorder(wo);
      });

      const lastWO = localStorage.getItem("lastWorkorder");
      if (lastWO) {
        woInput.value = lastWO;
        searchWorkorder(lastWO);
      } else {
        hideLoading(); // Hide loading if no WO is loaded
      }

      /* =======================
        Scan Modal + Scanner
      ======================== */
      async function updateTaskStatus(taskId, newStatus) {
        try {
          // üîπ Update Firestore task
          await updateDoc(doc(db, "tasks", taskId), { status: newStatus });

          // üîπ Update local cache
          const idx = allDocs.findIndex((d) => d.id === taskId);
          if (idx !== -1) {
            allDocs[idx] = { ...allDocs[idx], status: newStatus };

            // üîπ Log history to Firestore
            await logHistoryEntry(allDocs[idx], newStatus);
          }

          // üîπ Refresh UI
          applyFilters();

          showToast(`Status updated to ${newStatus}`, "success");
          return true;
        } catch (err) {
          console.error(err);
          showToast(`Failed to update task ${taskId}`, "error");
          return false;
        }
      }

      function showToast(message, type = "info", duration = 4000) {
        const container = document.getElementById("toastContainer");
        // Clear previous toasts to avoid stacking
        // container.innerHTML = "";

        const toast = document.createElement("div");
        toast.className = `toast ${type}`;
        toast.textContent = message;

        container.appendChild(toast);

        setTimeout(() => toast.classList.add("show"), 50);

        setTimeout(() => {
          toast.classList.remove("show");
          setTimeout(() => toast.remove(), 400);
        }, duration);
      }

      function openModal() {
        scanModal.style.display = "flex";
      }
      function closeModal() {
        scanModal.style.display = "none";
      }

      const manualSeqInput = document.getElementById("manualSeqInput");
      const manualAddBtn = document.getElementById("manualAddBtn");

      let scannedTasks = []; // [{ id, display }]
      const scanResultsList = document.getElementById("scanResultsList");
      // REMOVED redundant const scannedList

      manualAddBtn.addEventListener("click", () => {
        const value = manualSeqInput.value.trim();
        if (value !== "") {
          handleScannedValue(value);
          manualSeqInput.value = "";
        }
      });
      manualSeqInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          manualAddBtn.click();
        }
      });

      function setScanning(active) {
        scanningActive = active;
        startScanBtn.classList.toggle("scanning", active);
        startScanBtn.disabled = active;
        stopScanBtn.style.display = active ? "inline-block" : "none";
        if (active) {
          barcodeInput.value = "";
          barcodeInput.focus();
        } else {
          barcodeInput.blur();
        }
      }

      // This function seems to be unused, renderQueuedList is used instead.
      // function renderScannedTasks() { ... }

      startScanBtn.addEventListener("click", () => {
        if (!currentWO && !woInput.value.trim()) {
          showToast("Enter a Workorder first, then click Search.", "info");
          return;
        }
        if (!currentWO && woInput.value.trim()) {
          searchWorkorder(woInput.value.trim());
        }
        setScanning(true);
        openModal();
      });

      stopScanBtn.addEventListener("click", () => setScanning(false));

      barcodeInput.addEventListener("keydown", (e) => {
        if (!scanningActive) return;
        if (e.key === "Enter") {
          const val = barcodeInput.value.trim();
          barcodeInput.value = "";
          if (val !== "") handleScannedValue(val);
        }
      });

      // üîç Fetch tasks by sequence and show results

      async function handleScannedValue(raw) {
        const num = Number(raw);
        if (Number.isNaN(num)) {
          showToast(`Invalid sequence (not a number): "${raw}"`, "error");
          return;
        }

        try {
          const qSeq = query(
            collection(db, "tasks"),
            where("wo", "==", currentWO),
            where("seq", "==", num)
          );
          const snap = await getDocs(qSeq);

          scanResultsList.innerHTML = "";

          if (snap.empty) {
            scanResultsList.innerHTML = `
        <tr>
          <td colspan="6" style="text-align:center; color:#777;">
            No tasks found for Seq ${num}
          </td>
        </tr>`;
            return;
          }

          let shown = 0;
          const showClosed = showClosedChk.checked;

          snap.docs.forEach((docSnap) => {
            const task = { id: docSnap.id, ...docSnap.data() };
            const isClosed = (task.status ?? "").toUpperCase() === "CLOSED";

            if (isClosed && !showClosed) return;

            if (activeSkill !== "CLEAR") {
              if (skillGroups[activeSkill]) {
                if (!skillGroups[activeSkill].includes(task.skill)) return;
              } else {
                if (task.skill !== activeSkill) return;
              }
            }

            shown++;
            scanResultsList.insertAdjacentHTML(
              "beforeend",
              `
        <tr>
          <td>${task.seq ?? ""}</td>
          <td>${task.task_card ?? ""}</td><td>${task.phase ?? "P?"}</td>
          <td>${task.skill ?? "GEN"}</td>
          <td>${task.status ?? "OPEN"}</td>
          <td>
            ${
              isClosed
                ? `<button type="button" data-reopen="${task.id}">Reopen</button>`
                : `<button type="button" data-add="${task.id}">Add</button>`
            }
          </td>
        </tr>
      `
            );
          });

          if (shown === 0) {
            scanResultsList.innerHTML = `
        <tr>
          <td colspan="6" style="text-align:center; color:#777;">
            No OPEN tasks found for Seq ${num}
          </td>
        </tr>`;
          }

          if (scanModal.style.display !== "flex") openModal();
        } catch (err) {
          console.error(err);
          showToast("Error fetching tasks.", "error");
        }
      }

      // ‚ûï Add task to queue
      scanResultsList.addEventListener("click", (e) => {
        const btn = e.target.closest("button[data-add]");
        if (!btn) return;

        const taskId = btn.getAttribute("data-add");

        if (scannedTasks.some((t) => t.id === taskId)) {
          showToast("Task already queued", "info");
          return;
        }

        const row = btn.closest("tr");
        const seq = row.children[0].textContent.trim();
        const task_card = row.children[1].textContent.trim(); // ADDED
        const phase = row.children[2].textContent.trim(); // Was [1]
        const skill = row.children[3].textContent.trim(); // Was [2]
        const status = row.children[4].textContent.trim(); // Was [3]

        scannedTasks.push({
          id: taskId,
          seq,
          task_card, // ADDED
          phase,
          skill,
          status,
          // Updated display string to include task_card (optional)
          display: `Seq ${seq}-${task_card}-${phase}-${skill}-${status}`,
        });

        renderQueuedList();
        row.remove();
      });

      // Handle Re-open click
      scanResultsList.addEventListener("click", async (e) => {
        const reopenBtn = e.target.closest("button[data-reopen]");
        if (!reopenBtn) return;

        const taskId = reopenBtn.getAttribute("data-reopen");
        const ok = await updateTaskStatus(taskId, "OPEN");
        if (!ok) return;

        const row = reopenBtn.closest("tr");
        row.children[3].textContent = "OPEN";
        reopenBtn.outerHTML = `<button type="button" data-add="${taskId}">Add</button>`;
        showToast("Task reopened ‚úÖ", "success");
      });

      // üìã Render queued list
      function renderQueuedList() {
        scannedList.innerHTML = "";

        if (!scannedTasks.length) {
          scannedList.innerHTML = `
      <tr>
        <td colspan="6" style="text-align:center; color:#777;">No tasks queued</td>
      </tr>`;
        } else {
          scannedTasks.forEach((task) => {
            scannedList.insertAdjacentHTML(
              "beforeend",
              `
        <tr>
          <td>${task.seq}</td>
          <td>${task.task_card}</td><td>${task.phase}</td>
          <td>${task.skill}</td>
          <td>${task.status}</td>
          <td>
            <button type="button" data-remove="${task.id}">Remove</button>
          </td>
        </tr>
      `
            );
          });
        }
        scanCountEl.textContent = String(scannedTasks.length);
      }

      // ‚ùå Remove from queue (and send back to Matching list)
      scannedList.addEventListener("click", (e) => {
        const btn = e.target.closest("button[data-remove]");
        if (!btn) return;

        const id = btn.getAttribute("data-remove");
        const task = scannedTasks.find((t) => t.id === id);
        scannedTasks = scannedTasks.filter((t) => t.id !== id);
        renderQueuedList();

        if (task) {
          scanResultsList.insertAdjacentHTML(
            "beforeend",
            `
      <tr>
        <td>${task.seq}</td>
       <td>${task.task_card}</td> <td>${task.phase}</td>
        <td>${task.skill}</td>
        <td>${task.status}</td>
        <td>
          <button type="button" data-add="${task.id}">Add</button>
        </td>
      </tr>
      `
          );
        }
      });

      // ‚úÖ Submit queued tasks
      submitScanBtn.addEventListener("click", async () => {
        if (!currentWO) {
          showToast("Please search a Workorder first.", "error");
          return;
        }
        if (!scannedTasks.length) {
          showToast("No tasks queued.", "info");
          return;
        }

        closeModal();
        setScanning(false);
        showLoading();

        let updated = 0;
        try {
          for (const task of scannedTasks) {
            const ok = await updateTaskStatus(task.id, "CLOSED");
            if (ok) updated++;
          }
        } catch (err) {
          console.error(err);
          showToast("Error while updating tasks. Please try again.", "error");
        } finally {
          applyFilters();
          hideLoading();

          document
            .querySelectorAll(".skill-filters button")
            .forEach((b) => b.classList.remove("active"));

          const activeBtn = document.querySelector(
            `.skill-filters button[data-skill="${activeSkill}"]`
          );
          if (activeBtn) activeBtn.classList.add("active");
        }

        scannedTasks = [];
        renderQueuedList();
        scanResultsList.innerHTML = "";
        showToast(
          `Updated to CLOSED: ${updated}`,
          updated ? "success" : "info"
        );
      });

      closeScanBtn.addEventListener("click", () => {
        closeModal();
        setScanning(false);
        showClosedChk.checked = false;
      });
      clearScanBtn.addEventListener("click", () => {
        scannedTasks = [];
        renderQueuedList();
        scanResultsList.innerHTML = "";
      });

      renderQueuedList();

      // Digital Logbook Button
      document.getElementById("logbookBtn").addEventListener("click", () => {
        const currentWO = document.getElementById("woInput").value?.trim();
        // Use the activeSkill state variable
        const selectedSkill = activeSkill !== "CLEAR" ? activeSkill : "";

        if (!currentWO) {
          showToast("Please select or enter a Work Order first.", "error");
          return;
        }

        const url = `digitallogbook.html?wo=${encodeURIComponent(
          currentWO
        )}&skill=${encodeURIComponent(selectedSkill)}`;
        window.open(url, "_blank");
      });

      document.getElementById("manualTrigger").addEventListener("click", () => {
        const container = document.getElementById("dynamicBadgeContainer");
        container.innerHTML = `<div class="comment-badge" data-skill="${activeSkill}"></div>`;

        const badge = document.querySelector(
          `.comment-badge[data-skill="${activeSkill}"]`
        );
        if (badge) badge.click();
      });

      /**
       * Handles clicking the history panel.
       * This will "mark as read" all new items, make them glow, and reset the badge.
       */
      document.getElementById("historyBadge").addEventListener("click", () => {
        // If there are no new items, do nothing
        if (newHistoryItems.length === 0) return;

        // 1. Clear any old glows
        clearGlow();
        clearGlowState();

        // 2. Loop through all NEW item IDs and make them glow
        newHistoryItems.forEach((id) => {
          const li = document.querySelector(`#historyList [data-id="${id}"]`);
          if (li) {
            const statusEl = li.querySelector(".status");
            let glowClass = "pulse-glow-amber"; // Default glow

            if (statusEl) {
              const statusText = statusEl.textContent.trim().toUpperCase();
              if (statusText.includes("COMPLETED")) {
                glowClass = "pulse-glow-green";
              } else if (statusText.includes("RE-OPEN")) {
                glowClass = "pulse-glow-blue";
              } else if (
                statusText.includes("WARNING")||
                statusText.includes("NEWLY ADDED")
              ) {
                glowClass = "pulse-glow-amber";
              }
            }

            li.classList.add(glowClass);
            saveGlowState(id, glowClass); // Save glow to localStorage
          }
        });

        // 3. Reset the counter and hide the badge
        newHistoryItems = [];
        updateHistoryBadge();
      });

      async function renderJCChart(workorder, filteredDocs = []) {
        const getLocalDateKey = (date) => {
          if (!date || isNaN(date.getTime())) return null;
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, "0");
          const day = String(date.getDate()).padStart(2, "0");
          return `${year}-${month}-${day}`;
        };

        if (!workorder) {
          console.warn("‚ö†Ô∏è No workorder specified for JC chart.");
          return;
        }

        const workorderValue = isNaN(workorder) ? workorder : Number(workorder);

        // -----------------------------
        // üîπ Get Target Data (from Firestore)
        // -----------------------------
        const q = query(
          collection(db, "jctargets"),
          where("wo", "==", workorderValue),
          orderBy("tdate")
        );

        const snap = await getDocs(q);
        const rawData = [];

        snap.forEach((doc) => {
          const d = doc.data();
          if (!d.tdate || !d.tasktarget) return;

          const date = d.tdate.toDate?.() || new Date(d.tdate);
          const dateKey = getLocalDateKey(date);
          if (!dateKey) return;

          const tasktarget = Number(d.tasktarget) || 0;
          const skill = d.skill || "Unassigned";
          rawData.push({ dateKey, tasktarget, skill });
        });

        // -----------------------------
        // üîπ Filter by active skill
        // -----------------------------
        let filteredTarget = rawData;
        if (activeSkill && activeSkill !== "CLEAR") {
          const selectedSkills = skillGroups[activeSkill] || [activeSkill];
          filteredTarget = rawData.filter((d) =>
            selectedSkills.includes(d.skill)
          );
        }

        // -----------------------------
        // üîπ Group target totals per date
        // -----------------------------
        const groupedTarget = {};
        filteredTarget.forEach(({ dateKey, tasktarget }) => {
          groupedTarget[dateKey] = (groupedTarget[dateKey] || 0) + tasktarget;
        });

        // -----------------------------
        // üÜï Get Actual Closed Tasks (from `history`)
        // -----------------------------
        const histQ = query(
          collection(db, "history"),
          where("wo", "==", workorderValue)
        );

        const histSnap = await getDocs(histQ);
        const historyDocs = [];
        const uniqueTasks = new Set();

        histSnap.forEach((doc) => {
          const h = doc.data();
          if (!h.timestamp) return;

          if (activeSkill && activeSkill !== "CLEAR") {
            const selectedSkills = skillGroups[activeSkill] || [activeSkill];
            if (!selectedSkills.includes(h.skill)) return;
          }

          const status = (h.status || "").toLowerCase();
          if (
            status !== "closed" &&
            status !== "completed" &&
            status !== "cancel"
          ) {
            return;
          }

          const uniqueKey = `${h.seq || ""}-${h.task_card || ""}`.trim();
          if (uniqueTasks.has(uniqueKey)) return;
          uniqueTasks.add(uniqueKey);

          const date = h.timestamp.toDate?.() || new Date(h.timestamp);
          const dateKey = getLocalDateKey(date);
          if (!dateKey) return;

          historyDocs.push({ dateKey });
        });

        // -----------------------------
        // üîπ Group closed count per date
        // -----------------------------
        const groupedActual = {};
        historyDocs.forEach(({ dateKey }) => {
          groupedActual[dateKey] = (groupedActual[dateKey] || 0) + 1;
        });

        // -----------------------------
        // ‚úÖ Build a master x-axis from BOTH target and actual dates
        // -----------------------------
        const allDatesSet = new Set([
          ...Object.keys(groupedTarget),
          ...Object.keys(groupedActual),
        ]);

        const sortedDates = [...allDatesSet].sort(
          (a, b) => new Date(a) - new Date(b)
        );

        if (sortedDates.length === 0) {
          console.warn("‚ÑπÔ∏è No target or actual data found for WO:", workorder);
          if (window.jcChartInstance) {
            window.jcChartInstance.destroy();
            window.jcChartInstance = null;
          }
          return;
        }

        // -----------------------------
        // üîπ Compute cumulative target
        // -----------------------------
        const labels = [];
        const cumulativeTargets = [];
        let runningTarget = 0;

        sortedDates.forEach((d, i) => {
          runningTarget += groupedTarget[d] || 0;
          labels.push(`Day ${i + 1} (${d.slice(5)})`); // Shorten label
          cumulativeTargets.push(runningTarget);
        });

        // -----------------------------
        // üîπ Compute cumulative actual closed (cut off at today)
        // -----------------------------
        const cumulativeActual = [];
        let runningActual = 0;
        const todayKey = getLocalDateKey(new Date());

        sortedDates.forEach((d) => {
          if (d <= todayKey) {
            runningActual += groupedActual[d] || 0;
            cumulativeActual.push(runningActual);
          } else {
            cumulativeActual.push(null);
          }
        });

        // -----------------------------
        // üîπ Chart Title
        // -----------------------------
        const chartTitle =
          activeSkill && activeSkill !== "CLEAR"
            ? `Target vs Actual Closed ‚Äî ${activeSkill}`
            : "Target vs Actual Closed Tasks";

        // -----------------------------
        // üé® Render / Update Chart
        // -----------------------------
        const ctx =
          window.jcChartCtx ||
          (window.jcChartCtx = document
            .getElementById("jcChart")
            .getContext("2d"));

        if (window.jcChartInstance) {
          window.jcChartInstance.data.labels = labels;
          window.jcChartInstance.data.datasets[0].data = cumulativeTargets;
          window.jcChartInstance.data.datasets[1].data = cumulativeActual;
          window.jcChartInstance.options.plugins.title.text = chartTitle;
          window.jcChartInstance.update("active");
          return;
        }

        window.jcChartInstance = new Chart(ctx, {
          type: "line",
          data: {
            labels,
            datasets: [
              {
                label: "Cumulative Target",
                data: cumulativeTargets,
                borderColor: "rgba(5, 22, 77, 1)", // Lufthansa Blue
                backgroundColor: "rgba(5, 22, 77, 0.1)",
                borderWidth: 2,
                fill: true,
                tension: 0.35,
                pointRadius: 3,
              },
              {
                label: "Cumulative Closed",
                data: cumulativeActual,
                borderColor: "rgba(34,197,94,1)", // Green
                backgroundColor: "rgba(34,197,94,0.1)",
                borderWidth: 2,
                fill: false,
                tension: 0.35,
                pointRadius: 3,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            animation: { duration: 800, easing: "easeOutQuart" },
            plugins: {
              legend: {
                display: true,
                position: "bottom",
                labels: {
                  usePointStyle: true,
                  boxWidth: 8,
                  font: { size: 12, weight: "500" },
                  color: "#374151",
                },
              },
              title: {
                display: true,
                text: chartTitle, // Use the title
                font: { size: 14, weight: "600" },
                color: "#333",
              },
              tooltip: {
                backgroundColor: "#1f2937",
                titleColor: "#f9fafb",
                bodyColor: "#f9fafb",
                callbacks: {
                  label: (ctx) =>
                    `${
                      ctx.dataset.label
                    }: ${ctx.parsed.y.toLocaleString()} tasks`,
                },
              },
            },
            scales: {
              x: {
                title: { display: false },
                grid: { display: false },
                ticks: { color: "#6b7280", font: { size: 11 } },
              },
              y: {
                beginAtZero: true,
                title: { display: true, text: "Cumulative Tasks" },
                grid: { color: "rgba(107,114,128,0.1)", drawBorder: false },
                ticks: {
                  color: "#6b7280",
                  font: { size: 11 },
                  callback: (v) => v.toLocaleString(),
                },
              },
            },
          },
        });
      }
      const APP_VERSION = "1.0.1"; // Change this every time you deploy
const storedVersion = localStorage.getItem("app_version");

if (storedVersion && storedVersion !== APP_VERSION) {
  showUpdateNotification();
}

localStorage.setItem("app_version", APP_VERSION);

function showUpdateNotification() {
  const banner = document.createElement("div");
  banner.innerHTML = `
    <span style="color:#05164D;">New version available</span>
    <button id="refreshBtn">Refresh</button>
  `;

  banner.style.position = "fixed";
  banner.style.bottom = "20px";
  banner.style.right = "20px";
  banner.style.background = "#ffffff";
  banner.style.padding = "8px 16px";
  banner.style.borderRadius = "24px";
  banner.style.display = "flex";
  banner.style.alignItems = "center";
  banner.style.gap = "12px";
  banner.style.boxShadow = "0 4px 12px rgba(0,0,0,0.12)";
  banner.style.fontSize = "13px";
  banner.style.fontWeight = "500";
  banner.style.zIndex = "9999";
  banner.style.border = "1px solid #e5e5e5";

  document.body.appendChild(banner);

  const btn = document.getElementById("refreshBtn");

  btn.style.background = "#05164D";   // Lufthansa blue
  btn.style.color = "#ffffff";
  btn.style.border = "none";
  btn.style.padding = "6px 14px";
  btn.style.borderRadius = "16px";
  btn.style.cursor = "pointer";
  btn.style.fontSize = "12px";

  btn.onmouseenter = () => {
    btn.style.background = "#FFCC00"; // Lufthansa yellow hover
    btn.style.color = "#05164D";
  };

  btn.onmouseleave = () => {
    btn.style.background = "#05164D";
    btn.style.color = "#ffffff";
  };

  btn.onclick = () => location.reload();
}
    </script>
  </body>
</html>
